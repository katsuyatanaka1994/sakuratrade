name: workorder-ready

on:
  workflow_dispatch:
    inputs:
      base:
        description: 'Base branch for Implementation Draft PR (default: docs-sync/plan)'
        required: false
      plan_branch:
        description: 'Plan branch to read tasks from (default: docs-sync/plan)'
        required: false
  workflow_run:
    workflows: ['plan-sync/Validate']
    types: [completed]
  push:
    branches:
      - main
    paths:
      - docs/agile/plan.md

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  ready:
    name: workorder-ready
    env:
      WORKORDER_ALLOWED_PATHS: ${{ vars.WORKORDER_ALLOWED_PATHS || '' }}
      WORKORDER_BLOCKED_PATHS: ${{ vars.WORKORDER_BLOCKED_PATHS || 'alembic/**,infra/**,migrations/**' }}
      WORKORDER_MAX_TASK_LINES: ${{ vars.WORKORDER_MAX_TASK_LINES || '80' }}
      WORKORDER_MAX_PR_LINES: ${{ vars.WORKORDER_MAX_PR_LINES || '120' }}
      WORKORDER_MAX_FILE_LINES: ${{ vars.WORKORDER_MAX_FILE_LINES || '80' }}
      WORKORDER_MAX_TOTAL_LINES: ${{ vars.WORKORDER_MAX_TOTAL_LINES || '180' }}
      WORKORDER_MAX_LINES_PER_ITER: ${{ vars.WORKORDER_MAX_LINES_PER_ITER || '60' }}
      WORKORDER_MAX_ITERATIONS: ${{ vars.WORKORDER_MAX_ITERATIONS || '3' }}
      WORKORDER_MAX_CHANGED_FILES: ${{ vars.WORKORDER_MAX_CHANGED_FILES || '6' }}
      WORKORDER_MAX_AUTO_PRS: ${{ vars.WORKORDER_MAX_AUTO_PRS || vars.WORKORDER_MAX_OPEN_AUTOMATION_PRS || '2' }}
      WORKORDER_RUN_REPORT: tmp/workorder_limits_report.json
      WORKORDER_FAILURE_REASON: 'unknown'
      WORKORDER_FAIL_THRESHOLD: ${{ vars.WORKORDER_FAIL_THRESHOLD || '2' }}
      WORKORDER_ESCALATION_LABEL: ${{ vars.WORKORDER_ESCALATION_LABEL || 'workorder:suspended' }}
      WORKORDER_ESCALATION_MENTION: ${{ vars.WORKORDER_ESCALATION_MENTION || '' }}
    concurrency:
      group: docs-sync:workorder
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - name: Resolve run context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const set = (key, value) => core.setOutput(key, value ?? '');
            const event = context.eventName;
            const currentSha = context.sha || '';
            set('escalated', 'false');

            if (event === 'workflow_dispatch') {
              const baseInput = core.getInput('base') || 'docs-sync/plan';
              const planBranchInput = core.getInput('plan_branch') || baseInput;
              set('should_run', 'true');
              set('checkout_ref', `refs/heads/${planBranchInput}`);
              set('plan_branch', planBranchInput);
              set('pr_base', baseInput);
              set('trigger', 'workflow_dispatch');
              set('guard_ref', currentSha);
              return;
            }

            if (event === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (!run || run.conclusion !== 'success') {
                set('should_run', 'false');
                set('reason', 'upstream workflow not successful');
                return;
              }

              const trigger = run.event || 'workflow_run';
              const planBranch = 'docs-sync/plan';
              if (run.head_branch === 'docs-sync/workorder') {
                core.info('Skipping workorder-ready: ignore docs-sync/workorder self-trigger.');
                set('should_run', 'false');
                set('reason', 'docs-sync/workorder self-trigger');
                return;
              }

              const prInfo = Array.isArray(run.pull_requests) && run.pull_requests[0] ? run.pull_requests[0] : null;
              const runHeadSha = run.head_sha || '';

              if (trigger === 'pull_request_target') {
                if (!prInfo) {
                  set('should_run', 'false');
                  set('reason', 'workflow_run missing associated pull request');
                  return;
                }

                const prNumber = Number(prInfo.number);
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                const hasPlanSync = (pr.data.labels || []).some((label) => label?.name === 'plan:sync');
                if (!hasPlanSync) {
                  core.info(`Skipping workorder-ready: PR #${prNumber} missing plan:sync label.`);
                  set('should_run', 'false');
                  set('reason', 'source PR missing plan:sync label');
                  return;
                }
                if (pr.data.head?.ref === 'docs-sync/workorder') {
                  core.info('Skipping workorder-ready: docs-sync/workorder PR should not trigger workorder sync.');
                  set('should_run', 'false');
                  set('reason', 'source PR head is docs-sync/workorder');
                  return;
                }
                const escalationLabel = process.env.WORKORDER_ESCALATION_LABEL || 'workorder:suspended';
                const hasEscalationLabel = (pr.data.labels || []).some((label) => label?.name === escalationLabel);
                if (hasEscalationLabel) {
                  core.info(`Skipping workorder-ready: PR #${prNumber} marked with ${escalationLabel}.`);
                  set('should_run', 'false');
                  set('reason', 'workorder automation suspended');
                  set('source_pr', String(prNumber));
                  set('escalated', 'true');
                  return;
                }

                set('should_run', 'true');
                set('checkout_ref', `refs/heads/${planBranch}`);
                set('plan_branch', planBranch);
                set('pr_base', planBranch);
                set('source_pr', String(prNumber));
                set('source_head', pr.data.head?.ref ?? '');
                set('trigger', `plan-sync:${trigger}`);
                set('guard_ref', pr.data.head?.sha || runHeadSha);
                return;
              }

              if (trigger === 'workflow_dispatch' || trigger === 'issue_comment') {
                const escalationLabel = process.env.WORKORDER_ESCALATION_LABEL || 'workorder:suspended';
                if (prInfo && prInfo.number) {
                  try {
                    const prNumber = Number(prInfo.number);
                    const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                    const hasEscalationLabel = (pr.data.labels || []).some((label) => label?.name === escalationLabel);
                    if (hasEscalationLabel) {
                      core.info(`Skipping workorder-ready: PR #${prNumber} marked with ${escalationLabel}.`);
                      set('should_run', 'false');
                      set('reason', 'workorder automation suspended');
                      set('source_pr', String(prNumber));
                      set('escalated', 'true');
                      return;
                    }
                  } catch (error) {
                    core.warning(`Failed to inspect source PR escalation state: ${error}`);
                  }
                }
                set('should_run', 'true');
                set('checkout_ref', `refs/heads/${planBranch}`);
                set('plan_branch', planBranch);
                set('pr_base', planBranch);
                set('source_pr', prInfo ? String(prInfo.number) : '');
                set('source_head', prInfo?.head_branch || '');
                set('trigger', `plan-sync:${trigger}`);
                set('guard_ref', runHeadSha);
                return;
              }

              set('should_run', 'false');
              set('reason', `unsupported workflow_run event: ${trigger}`);
              return;
            }

            if (event === 'push') {
              const ref = context.ref || '';
              if (!ref.startsWith('refs/heads/')) {
                set('should_run', 'false');
                set('reason', 'unsupported ref type');
                return;
              }
              const branch = ref.replace('refs/heads/', '');
              set('should_run', 'true');
              set('checkout_ref', ref);
              set('plan_branch', branch);
              set('pr_base', branch);
              set('trigger', 'push');
              set('guard_ref', currentSha);
              return;
            }

            set('should_run', 'false');
            set('reason', `unsupported event: ${event}`);
            set('guard_ref', currentSha);

      - name: Skip (no action required)
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "workorder-ready skipped: ${{ steps.context.outputs.reason || 'condition not met' }}"

      - name: Create GitHub App token
        if: steps.context.outputs.should_run == 'true'
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          owner: ${{ github.repository_owner }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Checkout target revision
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Configure git user
        if: steps.context.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create workorder branch
        if: steps.context.outputs.should_run == 'true'
        run: |
          git checkout -B docs-sync/workorder

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: steps.context.outputs.should_run == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install PyYAML==6.0.2

      - name: Sync workorder metadata
        if: steps.context.outputs.should_run == 'true'
        id: sync
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_cli ready

      - name: Show workorder_sync_plan
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -f workorder_sync_plan.json ]; then
            cat workorder_sync_plan.json
          fi

      - name: Prepare guard script
        if: steps.context.outputs.should_run == 'true'
        id: guard-script
        run: |
          set -euo pipefail
          mkdir -p tmp
          ref="${{ steps.context.outputs.guard_ref || '' }}"
          if [ -n "$ref" ]; then
            git fetch --no-tags --depth=1 origin "$ref"
            git show "$ref":scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "Failed to load scripts/workorder_guard.py from $ref" >&2
              exit 1
            }
          else
            git show HEAD:scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "scripts/workorder_guard.py not found in current ref" >&2
              exit 1
            }
          fi
          echo "script_path=$(pwd)/tmp/workorder_guard.py" >> "$GITHUB_OUTPUT"

      - name: Run workorder guard
        if: steps.context.outputs.should_run == 'true'
        id: guard
        continue-on-error: true
        run: |
          set -euo pipefail
          python3 "${{ steps.guard-script.outputs.script_path }}"

      - name: Handle guard outcome
        if: steps.context.outputs.should_run == 'true' && steps.guard.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ env.WORKORDER_RUN_REPORT }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const fs = require('fs');
            const path = process.env.REPORT_PATH || 'tmp/workorder_limits_report.json';
            let report;
            try {
              report = JSON.parse(fs.readFileSync(path, 'utf-8'));
            } catch (error) {
              core.setFailed(`workorder guard failed but report ${path} could not be read: ${error.message}`);
              return;
            }

            const status = report.status || 'unknown';
            const stats = report.stats || {};
            const limits = report.limits || {};

            const fmtList = (items) => (items && items.length ? items.join(', ') : 'unknown');
            let message;
            if (status === 'disallowed') {
              message = `üõë workorder-ready stopped: disallowed paths detected (${fmtList(report.disallowed_files || [])}).`;
            } else if (status === 'blocked_paths') {
              message = `üõë workorder-ready stopped: blocked paths detected (${fmtList(report.blocked_files || [])}).`;
            } else if (status === 'limit_exceeded') {
              const reasons = [];
              for (const item of report.file_over_limit || []) {
                reasons.push(`${item.path} (${item.total}/${item.limit})`);
              }
              if (report.total_over_limit) {
                const actual = stats.total_lines ?? 'unknown';
                const limit = limits.max_total_changed_lines ?? (limits.max_changed_lines || {}).per_pr ?? 'unknown';
                reasons.push(`total lines ${actual}/${limit}`);
              }
              if (report.file_count_over_limit) {
                const actualFiles = stats.file_count ?? 'unknown';
                const limitFiles = limits.max_changed_files ?? 'unknown';
                reasons.push(`file count ${actualFiles}/${limitFiles}`);
              }
              const detail = reasons.length ? reasons.join('; ') : 'limit exceeded';
              message = `üõë workorder-ready stopped: guard limits hit (${detail}).`;
            } else {
              message = `üõë workorder-ready stopped: guard status ${status}.`;
            }

            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No source PR available to attach guard failure comment.');
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', message);
            core.setFailed(message);

      - name: Upload guard report
        if: always() && steps.context.outputs.should_run == 'true' && hashFiles(env.WORKORDER_RUN_REPORT) != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-limits-report
          path: ${{ env.WORKORDER_RUN_REPORT }}

      - name: Detect workorder changes
        if: steps.context.outputs.should_run == 'true'
        id: changes
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/agile/workorder.md workorder_sync_plan.json; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Enforce automation PR ceiling
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        uses: actions/github-script@v7
        env:
          MAX_AUTO_PRS: ${{ env.WORKORDER_MAX_AUTO_PRS }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const limitRaw = process.env.MAX_AUTO_PRS || '0';
            const limit = Number(limitRaw);
            if (!Number.isFinite(limit) || limit <= 0) {
              core.info(`Automation PR ceiling disabled (max=${limitRaw}).`);
              return;
            }
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 100 });
            const open = prs.data.length;
            if (open >= limit) {
              const message = `üõë workorder-ready stopped: open docs-sync/workorder PRs (${open}/${limit}).`;
              if (process.env.SOURCE_PR) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: Number(process.env.SOURCE_PR),
                  body: message,
                });
              }
              core.exportVariable('WORKORDER_FAILURE_REASON', message);
              core.setFailed(message);
              return;
            }
            core.info(`Open docs-sync/workorder PRs: ${open}/${limit}`);

      - name: Comment no-op result
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true' && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: '‚ÑπÔ∏è workorder-ready „ÇíÂÆüË°å„Åó„Åæ„Åó„Åü„Åå„ÄÅËá™ÂãïÊõ¥Êñ∞„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü (No-Op)„ÄÇ'
            });

      - name: Create / update workorder PR
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        id: create-pr
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
        run: |
          set -euo pipefail
          git add docs/agile/workorder.md workorder_sync_plan.json
          if git diff --cached --quiet; then
            echo "No workorder changes to commit"
            exit 0
          fi
          git commit -m "chore(workorder): sync workorder AUTO sections"
          git push --force-with-lease origin docs-sync/workorder
          SNAPSHOT=$(python3 -c 'import json;print(json.load(open("workorder_sync_plan.json","r",encoding="utf-8"))["plan_snapshot_id"])')
          TASKS=$(python3 -c 'import json;data=json.load(open("workorder_sync_plan.json","r",encoding="utf-8"));print(", ".join(data.get("task_ids", [])))')
          TRIGGER="${{ steps.context.outputs.trigger }}"
          SOURCE_HEAD="${{ steps.context.outputs.source_head || '' }}"
          python3 -c 'import sys;from pathlib import Path;trigger,head,snapshot,tasks=sys.argv[1:5];lines=["Automated workorder sync run.","",f"- Trigger: {trigger}"];\
          lines.append(f"- Source ref: `{head}`") if head else None;\
          lines.append(f"- plan_snapshot_id: {snapshot}") if snapshot else None;\
          lines.append(f"- Tasks: {tasks}") if tasks else None;\
          Path("/tmp/workorder-body.txt").write_text("\n".join(lines)+"\n",encoding="utf-8")' "$TRIGGER" "$SOURCE_HEAD" "$SNAPSHOT" "$TASKS"
          if gh pr view docs-sync/workorder >/dev/null 2>&1; then
            gh pr edit docs-sync/workorder \
              --title "[workorder-ready] docs: sync workorder auto sections" \
              --body-file /tmp/workorder-body.txt \
              --base ${{ steps.context.outputs.pr_base }}
          else
            gh pr create \
              --draft \
              --title "[workorder-ready] docs: sync workorder auto sections" \
              --body-file /tmp/workorder-body.txt \
              --base ${{ steps.context.outputs.pr_base }} \
              --head docs-sync/workorder
          fi

      - name: Comment PR link
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.source_pr != '' && steps.changes.outputs.changed == 'true'
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (!prs.data.length) {
              console.log('No workorder-ready PR to comment');
              return;
            }
            const url = prs.data[0].html_url;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: `üõ†Ô∏è workorder-ready: ${url}`,
            });

      - name: Note no-op in logs
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true'
        run: echo "workorder-ready completed without changes"

      - name: Reset failure ledger
        if: steps.context.outputs.should_run == 'true' && success() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.info('Reset skipped: missing source PR number.');
              return;
            }

            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';
            let ledger = null;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to inspect failure ledger: ${error}`);
            }

            if (ledger) {
              try {
                await github.rest.issues.deleteComment({ owner, repo, comment_id: ledger.id });
                core.info(`Deleted failure ledger comment (${ledger.id}).`);
              } catch (error) {
                core.warning(`Failed to delete ledger comment: ${error}`);
              }
            }

            const labelName = (process.env.ESCALATION_LABEL || '').trim();
            if (labelName) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: labelName });
                core.info(`Removed escalation label '${labelName}'.`);
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Escalation label '${labelName}' not present on PR #${issueNumber}.`);
                } else {
                  core.warning(`Failed to remove escalation label '${labelName}': ${error}`);
                }
              }
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', '');
            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`ÈÄ£Á∂öÂ§±Êïó„Ç´„Ç¶„É≥„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü (PR #${issueNumber}).`, true)
              .write();

      - name: Record failure ledger
        if: failure() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          FAILURE_REASON: ${{ env.WORKORDER_FAILURE_REASON }}
          FAIL_THRESHOLD: ${{ env.WORKORDER_FAIL_THRESHOLD }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
          ESCALATION_MENTION: ${{ env.WORKORDER_ESCALATION_MENTION }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.warning('Failure ledger skipped: missing source PR number.');
              return;
            }

            const threshold = Number.parseInt(process.env.FAIL_THRESHOLD || '0', 10);
            const labelName = (process.env.ESCALATION_LABEL || 'workorder:suspended').trim();
            const mention = (process.env.ESCALATION_MENTION || '').trim();
            const rawReason = process.env.FAILURE_REASON || '';
            const compactReason = rawReason ? rawReason.replace(/\s+/g, ' ').trim() : 'Ë©≥Á¥∞Êú™Ë®≠ÂÆö';
            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';

            let ledger = null;
            let count = 0;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  const match = (comment.body || '').match(/count:\s*(\d+)/i);
                  if (match) {
                    const parsed = Number.parseInt(match[1], 10);
                    if (Number.isFinite(parsed)) {
                      count = parsed;
                    }
                  }
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to read failure ledger comment: ${error}`);
            }

            count += 1;
            const nowIso = new Date().toISOString();
            const bodyLines = [
              marker,
              `count: ${count}`,
              `last_failure: ${nowIso}`,
              `reason: ${compactReason}`,
            ];
            const ledgerBody = bodyLines.join('\n');

            try {
              if (ledger) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: ledger.id, body: ledgerBody });
                core.info(`Updated failure ledger comment (${ledger.id}) to ${count}.`);
              } else {
                ledger = await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: ledgerBody });
                core.info(`Created failure ledger comment (${ledger.id}) with count ${count}.`);
              }
            } catch (error) {
              core.warning(`Failed to update failure ledger comment: ${error}`);
            }

            if (compactReason) {
              core.info(`Recorded failure reason: ${compactReason}`);
            }

            let escalated = false;
            if (threshold > 0 && count >= threshold) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: 'B60205',
                    description: 'Workorder automation suspended after repeated failures',
                  });
                  core.info(`Created escalation label '${labelName}'.`);
                } else {
                  core.warning(`Failed to verify escalation label '${labelName}': ${error}`);
                }
              }

              let hasLabel = false;
              try {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issueNumber });
                hasLabel = (pr.data.labels || []).some((label) => label?.name === labelName);
              } catch (error) {
                core.warning(`Failed to fetch PR #${issueNumber} for label check: ${error}`);
              }

              if (!hasLabel) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [labelName] });
                  hasLabel = true;
                  core.info(`Applied escalation label '${labelName}' to PR #${issueNumber}.`);
                } catch (error) {
                  core.warning(`Failed to add escalation label '${labelName}': ${error}`);
                }
              }

              if (hasLabel) {
                if (count === threshold) {
                  let message = `‚ö†Ô∏è workorder-ready „ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü„ÄÇÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞„ÅåÈñæÂÄ§ (${threshold}) „Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ\n`;
                  message += `- ÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞: ${count}\n`;
                  if (rawReason) {
                    message += `- ÊúÄÂæå„ÅÆÂ§±ÊïóÁêÜÁî±: ${rawReason.trim()}\n`;
                  }
                  message += `- ÂØæÂøú: ÂéüÂõ†„ÇíËß£Ê∂à„Åó„ÄÅ„É©„Éô„É´ '${labelName}' „ÇíÂ§ñ„Åó„Å¶„Åã„ÇâÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
                  if (mention) {
                    message = `${mention}\n\n${message}`;
                  }
                  try {
                    await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: message });
                  } catch (error) {
                    core.warning(`Failed to create escalation comment: ${error}`);
                  }
                }
                escalated = true;
              }
            }

            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`PR #${issueNumber} failure count: ${count}${threshold > 0 ? ` / threshold ${threshold}` : ''}.`, true)
              .write();

            if (!escalated) {
              core.info(`Recorded failure ${count} (threshold ${threshold || 'disabled'}).`);
            }
