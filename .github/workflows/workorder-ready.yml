name: workorder-ready

on:
  workflow_dispatch:
    inputs:
      base:
        description: 'Base branch for Implementation Draft PR (default: docs-sync/plan)'
        required: false
      plan_branch:
        description: 'Plan branch to read tasks from (default: docs-sync/plan)'
        required: false
  workflow_run:
    workflows: ['plan-sync/Validate']
    types: [completed]
  push:
    branches:
      - main
    paths:
      - docs/agile/plan.md

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  ready:
    name: workorder-ready
    env:
      WORKORDER_ALLOWED_PATHS: ${{ vars.WORKORDER_ALLOWED_PATHS || '' }}
      WORKORDER_BLOCKED_PATHS: ${{ vars.WORKORDER_BLOCKED_PATHS || 'alembic/**,infra/**,migrations/**' }}
      WORKORDER_MAX_TASK_LINES: ${{ vars.WORKORDER_MAX_TASK_LINES || '80' }}
      WORKORDER_MAX_PR_LINES: ${{ vars.WORKORDER_MAX_PR_LINES || '120' }}
      WORKORDER_MAX_FILE_LINES: ${{ vars.WORKORDER_MAX_FILE_LINES || '80' }}
      WORKORDER_MAX_TOTAL_LINES: ${{ vars.WORKORDER_MAX_TOTAL_LINES || '180' }}
      WORKORDER_MAX_LINES_PER_ITER: ${{ vars.WORKORDER_MAX_LINES_PER_ITER || '60' }}
      WORKORDER_MAX_ITERATIONS: ${{ vars.WORKORDER_MAX_ITERATIONS || '3' }}
      WORKORDER_MAX_CHANGED_FILES: ${{ vars.WORKORDER_MAX_CHANGED_FILES || '6' }}
      WORKORDER_MAX_AUTO_PRS: ${{ vars.WORKORDER_MAX_AUTO_PRS || vars.WORKORDER_MAX_OPEN_AUTOMATION_PRS || '2' }}
      WORKORDER_RUN_REPORT: tmp/workorder_limits_report.json
      WORKORDER_FAILURE_REASON: 'unknown'
      WORKORDER_FAIL_THRESHOLD: ${{ vars.WORKORDER_FAIL_THRESHOLD || '2' }}
      WORKORDER_ESCALATION_LABEL: ${{ vars.WORKORDER_ESCALATION_LABEL || 'workorder:suspended' }}
      WORKORDER_ESCALATION_MENTION: ${{ vars.WORKORDER_ESCALATION_MENTION || '' }}
      WORKORDER_AUDIT_LOG_PATH: docs/agile/workorder-audit.log
    concurrency:
      group: docs-sync:workorder
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - name: Resolve run context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const set = (key, value) => core.setOutput(key, value ?? '');
            const event = context.eventName;
            const currentSha = context.sha || '';
            set('escalated', 'false');

            if (event === 'workflow_dispatch') {
              const baseInput = core.getInput('base') || 'docs-sync/plan';
              const planBranchInput = core.getInput('plan_branch') || baseInput;
              set('should_run', 'true');
              set('checkout_ref', `refs/heads/${planBranchInput}`);
              set('plan_branch', planBranchInput);
              set('pr_base', baseInput);
              set('trigger', 'workflow_dispatch');
              set('guard_ref', currentSha);
              return;
            }

            if (event === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (!run || run.conclusion !== 'success') {
                set('should_run', 'false');
                set('reason', 'upstream workflow not successful');
                return;
              }

              const trigger = run.event || 'workflow_run';
              const planBranch = 'docs-sync/plan';
              if (run.head_branch === 'docs-sync/workorder') {
                core.info('Skipping workorder-ready: ignore docs-sync/workorder self-trigger.');
                set('should_run', 'false');
                set('reason', 'docs-sync/workorder self-trigger');
                return;
              }

              const prInfo = Array.isArray(run.pull_requests) && run.pull_requests[0] ? run.pull_requests[0] : null;
              const runHeadSha = run.head_sha || '';

              if (trigger === 'pull_request_target') {
                if (!prInfo) {
                  set('should_run', 'false');
                  set('reason', 'workflow_run missing associated pull request');
                  return;
                }

                const prNumber = Number(prInfo.number);
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                const hasPlanSync = (pr.data.labels || []).some((label) => label?.name === 'plan:sync');
                if (!hasPlanSync) {
                  core.info(`Skipping workorder-ready: PR #${prNumber} missing plan:sync label.`);
                  set('should_run', 'false');
                  set('reason', 'source PR missing plan:sync label');
                  return;
                }
                if (pr.data.head?.ref === 'docs-sync/workorder') {
                  core.info('Skipping workorder-ready: docs-sync/workorder PR should not trigger workorder sync.');
                  set('should_run', 'false');
                  set('reason', 'source PR head is docs-sync/workorder');
                  return;
                }
                const escalationLabel = process.env.WORKORDER_ESCALATION_LABEL || 'workorder:suspended';
                const hasEscalationLabel = (pr.data.labels || []).some((label) => label?.name === escalationLabel);
                if (hasEscalationLabel) {
                  core.info(`Skipping workorder-ready: PR #${prNumber} marked with ${escalationLabel}.`);
                  set('should_run', 'false');
                  set('reason', 'workorder automation suspended');
                  set('source_pr', String(prNumber));
                  set('escalated', 'true');
                  return;
                }

                set('should_run', 'true');
                set('checkout_ref', `refs/heads/${planBranch}`);
                set('plan_branch', planBranch);
                set('pr_base', planBranch);
                set('source_pr', String(prNumber));
                set('source_head', pr.data.head?.ref ?? '');
                set('trigger', `plan-sync:${trigger}`);
                set('guard_ref', pr.data.head?.sha || runHeadSha);
                return;
              }

              if (trigger === 'workflow_dispatch' || trigger === 'issue_comment') {
                const escalationLabel = process.env.WORKORDER_ESCALATION_LABEL || 'workorder:suspended';
                if (prInfo && prInfo.number) {
                  try {
                    const prNumber = Number(prInfo.number);
                    const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                    const hasEscalationLabel = (pr.data.labels || []).some((label) => label?.name === escalationLabel);
                    if (hasEscalationLabel) {
                      core.info(`Skipping workorder-ready: PR #${prNumber} marked with ${escalationLabel}.`);
                      set('should_run', 'false');
                      set('reason', 'workorder automation suspended');
                      set('source_pr', String(prNumber));
                      set('escalated', 'true');
                      return;
                    }
                  } catch (error) {
                    core.warning(`Failed to inspect source PR escalation state: ${error}`);
                  }
                }
                set('should_run', 'true');
                set('checkout_ref', `refs/heads/${planBranch}`);
                set('plan_branch', planBranch);
                set('pr_base', planBranch);
                set('source_pr', prInfo ? String(prInfo.number) : '');
                set('source_head', prInfo?.head_branch || '');
                set('trigger', `plan-sync:${trigger}`);
                set('guard_ref', runHeadSha);
                return;
              }

              set('should_run', 'false');
              set('reason', `unsupported workflow_run event: ${trigger}`);
              return;
            }

            if (event === 'push') {
              const ref = context.ref || '';
              if (!ref.startsWith('refs/heads/')) {
                set('should_run', 'false');
                set('reason', 'unsupported ref type');
                return;
              }
              const branch = ref.replace('refs/heads/', '');
              set('should_run', 'true');
              set('checkout_ref', ref);
              set('plan_branch', branch);
              set('pr_base', branch);
              set('trigger', 'push');
              set('guard_ref', currentSha);
              return;
            }

            set('should_run', 'false');
            set('reason', `unsupported event: ${event}`);
            set('guard_ref', currentSha);

      - name: Skip (no action required)
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "workorder-ready skipped: ${{ steps.context.outputs.reason || 'condition not met' }}"

      - name: Create GitHub App token
        if: steps.context.outputs.should_run == 'true'
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          owner: ${{ github.repository_owner }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Checkout target revision
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Configure git user
        if: steps.context.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create workorder branch
        if: steps.context.outputs.should_run == 'true'
        run: |
          git checkout -B docs-sync/workorder

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: steps.context.outputs.should_run == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install PyYAML==6.0.2

      - name: Sync workorder metadata
        if: steps.context.outputs.should_run == 'true'
        id: sync
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_cli ready

      - name: Show workorder_sync_plan
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -f workorder_sync_plan.json ]; then
            cat workorder_sync_plan.json
          fi

      - name: Prepare guard script
        if: steps.context.outputs.should_run == 'true'
        id: guard-script
        run: |
          set -euo pipefail
          mkdir -p tmp
          ref="${{ steps.context.outputs.guard_ref || '' }}"
          if [ -n "$ref" ]; then
            git fetch --no-tags --depth=1 origin "$ref"
            git show "$ref":scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "Failed to load scripts/workorder_guard.py from $ref" >&2
              exit 1
            }
          else
            git show HEAD:scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "scripts/workorder_guard.py not found in current ref" >&2
              exit 1
            }
          fi
          echo "script_path=$(pwd)/tmp/workorder_guard.py" >> "$GITHUB_OUTPUT"

      - name: Run workorder guard
        if: steps.context.outputs.should_run == 'true'
        id: guard
        continue-on-error: true
        run: |
          set -euo pipefail
          python3 "${{ steps.guard-script.outputs.script_path }}"

      - name: Parse guard status
        if: steps.context.outputs.should_run == 'true'
        id: guard-status
        run: |
          set -euo pipefail
          python3 <<'PY'
import json
import os
import pathlib

report_path = os.environ.get('WORKORDER_RUN_REPORT')
status = 'unknown'
treated = 'false'
disallowed = ''
limit_exceeded = 'false'
if report_path and pathlib.Path(report_path).is_file():
    with open(report_path, 'r', encoding='utf-8') as fh:
        data = json.load(fh)
    status = (data.get('status') or 'unknown').strip() or 'unknown'
    treated = 'true' if data.get('treated_as_noop') else 'false'
    disallowed = ','.join(data.get('disallowed_files') or [])
    over_limit = bool(data.get('file_over_limit')) or bool(data.get('total_over_limit')) or bool(data.get('file_count_over_limit'))
    limit_exceeded = 'true' if over_limit else 'false'
output_path = pathlib.Path(os.environ['GITHUB_OUTPUT'])
with output_path.open('a', encoding='utf-8') as fh:
    fh.write(f"status={status}\n")
    fh.write(f"treated_as_noop={treated}\n")
    fh.write(f"disallowed_files={disallowed}\n")
    fh.write(f"limit_exceeded={limit_exceeded}\n")
PY

      - name: Fail when disallowed hides limit breaches
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'disallowed' && steps.guard-status.outputs.limit_exceeded == 'true'
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const message = 'üõë workorder-ready stopped: disallowed paths were detected together with guard limit violations. ‰øÆÊ≠£Âæå„Å´ÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No source PR available to attach combined failure comment.');
            }
            core.setFailed(message);

      - name: Reset disallowed paths
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'disallowed'
        run: |
          set -euo pipefail
          python3 <<'PY'
import json
import os
import pathlib
import subprocess

report_path = os.environ.get('WORKORDER_RUN_REPORT')
if not report_path:
    raise SystemExit(0)
path = pathlib.Path(report_path)
if not path.is_file():
    raise SystemExit(0)
with path.open('r', encoding='utf-8') as fh:
    data = json.load(fh)
files = data.get('disallowed_files') or []
for item in files:
    if not item:
        continue
    subprocess.run(['git', 'checkout', '--', item], check=False)
PY

      - name: Record audit log entry
        if: steps.context.outputs.should_run == 'true'
        id: audit
        env:
          GUARD_STATUS: ${{ steps.guard-status.outputs.status || 'unknown' }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          SOURCE_HEAD: ${{ steps.context.outputs.source_head }}
          PR_BASE: ${{ steps.context.outputs.pr_base }}
          TRIGGER: ${{ steps.context.outputs.trigger }}
        run: |
          set -euo pipefail
          append_flag=""
          case "${GUARD_STATUS}" in
            ok|no_changes|disallowed)
              ;;
            *)
              append_flag="--skip-append"
              ;;
          esac
          cmd=(
            python3 -m scripts.workorder_audit
            --trigger "${TRIGGER}"
            --source-pr "${SOURCE_PR}"
            --source-head "${SOURCE_HEAD}"
            --pr-base "${PR_BASE}"
            --head-branch "docs-sync/workorder"
            --log "${WORKORDER_AUDIT_LOG_PATH}"
            --artifact tmp/workorder_audit_entry.json
          )
          if [ -n "${append_flag}" ]; then
            cmd+=("${append_flag}")
          fi
          "${cmd[@]}"

      - name: Upload audit log artifact
        if: always() && steps.context.outputs.should_run == 'true' && hashFiles('tmp/workorder_audit_entry.json') != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-audit-entry
          path: tmp/workorder_audit_entry.json

      - name: Handle guard outcome
        if: steps.context.outputs.should_run == 'true' && steps.guard.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ env.WORKORDER_RUN_REPORT }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const fs = require('fs');
            const path = process.env.REPORT_PATH || 'tmp/workorder_limits_report.json';
            let report;
            try {
              report = JSON.parse(fs.readFileSync(path, 'utf-8'));
            } catch (error) {
              core.setFailed(`workorder guard failed but report ${path} could not be read: ${error.message}`);
              return;
            }

            const status = report.status || 'unknown';
            const stats = report.stats || {};
            const limits = report.limits || {};

            const fmtList = (items) => (items && items.length ? items.join(', ') : 'unknown');
            let message;
            if (status === 'disallowed') {
              message = `üõë workorder-ready stopped: disallowed paths detected (${fmtList(report.disallowed_files || [])}).`;
            } else if (status === 'blocked_paths') {
              message = `üõë workorder-ready stopped: blocked paths detected (${fmtList(report.blocked_files || [])}).`;
            } else if (status === 'limit_exceeded') {
              const reasons = [];
              for (const item of report.file_over_limit || []) {
                reasons.push(`${item.path} (${item.total}/${item.limit})`);
              }
              if (report.total_over_limit) {
                const actual = stats.total_lines ?? 'unknown';
                const limit = limits.max_total_changed_lines ?? (limits.max_changed_lines || {}).per_pr ?? 'unknown';
                reasons.push(`total lines ${actual}/${limit}`);
              }
              if (report.file_count_over_limit) {
                const actualFiles = stats.file_count ?? 'unknown';
                const limitFiles = limits.max_changed_files ?? 'unknown';
                reasons.push(`file count ${actualFiles}/${limitFiles}`);
              }
              const detail = reasons.length ? reasons.join('; ') : 'limit exceeded';
              message = `üõë workorder-ready stopped: guard limits hit (${detail}).`;
            } else {
              message = `üõë workorder-ready stopped: guard status ${status}.`;
            }

            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No source PR available to attach guard failure comment.');
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', message);
            core.setFailed(message);

      - name: Upload guard report
        if: always() && steps.context.outputs.should_run == 'true' && hashFiles(env.WORKORDER_RUN_REPORT) != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-limits-report
          path: ${{ env.WORKORDER_RUN_REPORT }}

      - name: Detect workorder changes
        if: steps.context.outputs.should_run == 'true'
        id: changes
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/agile/workorder.md workorder_sync_plan.json "$WORKORDER_AUDIT_LOG_PATH"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Enforce automation PR ceiling
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        uses: actions/github-script@v7
        env:
          MAX_AUTO_PRS: ${{ env.WORKORDER_MAX_AUTO_PRS }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const limitRaw = process.env.MAX_AUTO_PRS || '0';
            const limit = Number(limitRaw);
            if (!Number.isFinite(limit) || limit <= 0) {
              core.info(`Automation PR ceiling disabled (max=${limitRaw}).`);
              return;
            }
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 100 });
            const open = prs.data.length;
            if (open >= limit) {
              const message = `üõë workorder-ready stopped: open docs-sync/workorder PRs (${open}/${limit}).`;
              if (process.env.SOURCE_PR) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: Number(process.env.SOURCE_PR),
                  body: message,
                });
              }
              core.exportVariable('WORKORDER_FAILURE_REASON', message);
              core.setFailed(message);
              return;
            }
            core.info(`Open docs-sync/workorder PRs: ${open}/${limit}`);

      - name: Comment no-op result
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true' && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: '‚ÑπÔ∏è workorder-ready „ÇíÂÆüË°å„Åó„Åæ„Åó„Åü„Åå„ÄÅËá™ÂãïÊõ¥Êñ∞„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü (No-Op)„ÄÇ'
            });

      - name: Prepare workorder commit
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true' && (steps.guard-status.outputs.status == 'ok' || steps.guard-status.outputs.status == 'no_changes' || steps.guard-status.outputs.status == 'disallowed')
        id: prepare_workorder
        env:
          GUARD_STATUS: ${{ steps.guard-status.outputs.status || 'unknown' }}
          TRIGGER: ${{ steps.context.outputs.trigger }}
          SOURCE_HEAD: ${{ steps.context.outputs.source_head || '' }}
        run: |
          set -euo pipefail
          git add docs/agile/workorder.md workorder_sync_plan.json "$WORKORDER_AUDIT_LOG_PATH"
          if git diff --cached --quiet; then
            {
              echo "commit_created=false"
              echo "before_sha="
              echo "after_sha="
              echo "body_path="
              echo "snapshot="
              echo "tasks_csv="
            } >> "$GITHUB_OUTPUT"
            echo "No workorder changes to commit"
            exit 0
          fi
          before_sha=$(git rev-parse HEAD)
          commit_msg="chore(workorder): sync workorder AUTO sections"
          if [ "${GUARD_STATUS}" = "disallowed" ]; then
            commit_msg="chore(workorder): record audit (disallowed)"
          elif [ "${GUARD_STATUS}" = "no_changes" ]; then
            commit_msg="chore(workorder): record audit (noop)"
          fi
          git commit -m "$commit_msg"
          after_sha=$(git rev-parse HEAD)
          export BEFORE_SHA="$before_sha"
          export AFTER_SHA="$after_sha"
          python3 <<'PY'
import json
import os
import pathlib

data = json.loads(pathlib.Path("workorder_sync_plan.json").read_text(encoding="utf-8"))
snapshot = data.get("plan_snapshot_id", "")
task_ids = [t for t in data.get("task_ids", []) if isinstance(t, str)]
tasks_csv = ", ".join(task_ids)
trigger = os.environ.get("TRIGGER") or "workorder-ready"
source_head = os.environ.get("SOURCE_HEAD") or ""
lines = ["Automated workorder sync run.", "", f"- Trigger: {trigger}"]
if source_head:
    lines.append(f"- Source ref: `{source_head}`")
if snapshot:
    lines.append(f"- plan_snapshot_id: {snapshot}")
if tasks_csv:
    lines.append(f"- Tasks: {tasks_csv}")

body_path = pathlib.Path("/tmp/workorder-body.txt")
body_path.parent.mkdir(parents=True, exist_ok=True)
body_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

output = pathlib.Path(os.environ["GITHUB_OUTPUT"])
before = os.environ.get("BEFORE_SHA", "")
after = os.environ.get("AFTER_SHA", "")
cwd = pathlib.Path.cwd()
try:
    rel_body = body_path.relative_to(cwd)
except ValueError:
    rel_body = body_path

with output.open("a", encoding="utf-8") as fh:
    fh.write("commit_created=true\n")
    fh.write(f"before_sha={before}\n")
    fh.write(f"after_sha={after}\n")
    fh.write(f"body_path={rel_body}\n")
    fh.write(f"snapshot={snapshot}\n")
    fh.write(f"tasks_csv={tasks_csv}\n")
PY
          echo "Prepared workorder commit ${after_sha}"

      - name: Setup Node for acceptance tests
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true'
        working-directory: frontend
        run: |
          set -euo pipefail
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install --no-audit --no-fund
          fi

      - name: Run workorder acceptance tests
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true'
        id: acceptance_tests
        continue-on-error: true
        env:
          SUMMARY_PATH: tmp/workorder_tests_summary.json
        run: |
          set -euo pipefail
          SUMMARY_PATH="${SUMMARY_PATH}"
          EXIT_CODE=0
          set +e
          python3 -m scripts.workorder_tests run --summary "$SUMMARY_PATH" --log-dir tmp/workorder_tests
          EXIT_CODE=$?
          set -e
          {
            echo "summary_path=$SUMMARY_PATH"
            echo "exit_code=$EXIT_CODE"
          } >> "$GITHUB_OUTPUT"
          exit $EXIT_CODE

      - name: Analyse acceptance summary
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true'
        id: acceptance_summary
        env:
          SUMMARY_PATH: ${{ steps.acceptance_tests.outputs.summary_path || '' }}
        run: |
          set -euo pipefail
          summary_path="${SUMMARY_PATH}"
          if [ -z "$summary_path" ] || [ ! -f "$summary_path" ]; then
            {
              echo "status=error"
              echo "summary_path=$summary_path"
              echo "failed_stage="
              echo "failed_check="
              echo "failed_command="
              echo "log_dir="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
          python3 <<'PY'
import json
import os
import pathlib

summary_path = pathlib.Path(os.environ['SUMMARY_PATH']).resolve()
data = json.loads(summary_path.read_text(encoding='utf-8'))
cwd = pathlib.Path.cwd()
try:
    rel_summary = summary_path.relative_to(cwd)
except ValueError:
    rel_summary = summary_path

log_dir = data.get('log_dir') or ''
if log_dir:
    log_path = cwd / log_dir
    try:
        rel_log = log_path.relative_to(cwd)
    except ValueError:
        rel_log = log_dir
else:
    rel_log = ''

output = pathlib.Path(os.environ['GITHUB_OUTPUT'])
with output.open('a', encoding='utf-8') as fh:
    fh.write(f"status={data.get('status', 'unknown')}\n")
    fh.write(f"summary_path={rel_summary}\n")
    fh.write(f"failed_stage={data.get('failed_stage') or ''}\n")
    fh.write(f"failed_check={data.get('failed_check') or ''}\n")
    fh.write(f"failed_command={data.get('failed_command') or ''}\n")
    fh.write(f"log_dir={rel_log}\n")
PY

      - name: Upload acceptance logs
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_tests.outputs.summary_path != '' && hashFiles('tmp/workorder_tests/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-tests-logs
          path: tmp/workorder_tests

      - name: Comment acceptance failure
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure' && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          FAILED_STAGE: ${{ steps.acceptance_summary.outputs.failed_stage }}
          FAILED_CHECK: ${{ steps.acceptance_summary.outputs.failed_check }}
          FAILED_COMMAND: ${{ steps.acceptance_summary.outputs.failed_command }}
          LOG_DIR: ${{ steps.acceptance_summary.outputs.log_dir }}
          SUMMARY_PATH: ${{ steps.acceptance_summary.outputs.summary_path }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const stage = process.env.FAILED_STAGE || 'unknown';
            const check = process.env.FAILED_CHECK || 'unknown';
            const command = process.env.FAILED_COMMAND || '';
            const logDir = process.env.LOG_DIR || 'tmp/workorder_tests';
            const summaryPath = process.env.SUMMARY_PATH || 'tmp/workorder_tests_summary.json';
            let body = 'üõë workorder-ready acceptance tests failed.\n';
            body += `- Stage: ${stage}\n`;
            body += `- Check: ${check}\n`;
            if (command) {
              body += `- Command: \`${command}\`\n`;
            }
            body += `- Logs: ${logDir} (artifact: workorder-tests-logs)\n`;
            body += `- Summary: ${summaryPath}\n`;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body,
            });
            const label = command ? `${check} (${stage})` : (check || stage);
            core.exportVariable('WORKORDER_FAILURE_REASON', `workorder tests failed: ${label}`);

      - name: Rollback workorder commit
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure'
        run: |
          set -euo pipefail
          git reset --hard ${{ steps.prepare_workorder.outputs.before_sha }}
          echo "Rolled back workorder commit due to failed acceptance tests"

      - name: Fail due to acceptance failure
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure'
        run: |
          echo "::error::workorder acceptance tests failed"
          exit 1

      - name: Push workorder branch
        if: steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && ((steps.guard-status.outputs.status == 'ok' && steps.acceptance_summary.outputs.status == 'success') || (steps.guard-status.outputs.status != 'ok'))
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
          BODY_PATH: ${{ steps.prepare_workorder.outputs.body_path }}
          PR_BASE: ${{ steps.context.outputs.pr_base }}
        run: |
          set -euo pipefail
          git push --force-with-lease origin docs-sync/workorder
          body_path="${BODY_PATH}"
          if [ -z "$body_path" ] || [ ! -f "$body_path" ]; then
            echo "PR body missing; skipped body update"
            exit 0
          fi
          if gh pr view docs-sync/workorder >/dev/null 2>&1; then
            gh pr edit docs-sync/workorder \
              --title "[workorder-ready] docs: sync workorder auto sections" \
              --body-file "$body_path" \
              --base "$PR_BASE"
          else
            gh pr create \
              --draft \
              --title "[workorder-ready] docs: sync workorder auto sections" \
              --body-file "$body_path" \
              --base "$PR_BASE" \
              --head docs-sync/workorder
          fi

      - name: Comment PR link
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.source_pr != '' && steps.prepare_workorder.outputs.commit_created == 'true' && ((steps.guard-status.outputs.status == 'ok' && steps.acceptance_summary.outputs.status == 'success') || (steps.guard-status.outputs.status != 'ok'))
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (!prs.data.length) {
              console.log('No workorder-ready PR to comment');
              return;
            }
            const url = prs.data[0].html_url;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: `üõ†Ô∏è workorder-ready: ${url}`,
            });

      - name: Note no-op in logs
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true'
        run: echo "workorder-ready completed without changes"

      - name: Reset failure ledger
        if: steps.context.outputs.should_run == 'true' && success() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.info('Reset skipped: missing source PR number.');
              return;
            }

            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';
            let ledger = null;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to inspect failure ledger: ${error}`);
            }

            if (ledger) {
              try {
                await github.rest.issues.deleteComment({ owner, repo, comment_id: ledger.id });
                core.info(`Deleted failure ledger comment (${ledger.id}).`);
              } catch (error) {
                core.warning(`Failed to delete ledger comment: ${error}`);
              }
            }

            const labelName = (process.env.ESCALATION_LABEL || '').trim();
            if (labelName) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: labelName });
                core.info(`Removed escalation label '${labelName}'.`);
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Escalation label '${labelName}' not present on PR #${issueNumber}.`);
                } else {
                  core.warning(`Failed to remove escalation label '${labelName}': ${error}`);
                }
              }
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', '');
            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`ÈÄ£Á∂öÂ§±Êïó„Ç´„Ç¶„É≥„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü (PR #${issueNumber}).`, true)
              .write();

      - name: Record failure ledger
        if: failure() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          FAILURE_REASON: ${{ env.WORKORDER_FAILURE_REASON }}
          FAIL_THRESHOLD: ${{ env.WORKORDER_FAIL_THRESHOLD }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
          ESCALATION_MENTION: ${{ env.WORKORDER_ESCALATION_MENTION }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.warning('Failure ledger skipped: missing source PR number.');
              return;
            }

            const threshold = Number.parseInt(process.env.FAIL_THRESHOLD || '0', 10);
            const labelName = (process.env.ESCALATION_LABEL || 'workorder:suspended').trim();
            const mention = (process.env.ESCALATION_MENTION || '').trim();
            const rawReason = process.env.FAILURE_REASON || '';
            const compactReason = rawReason ? rawReason.replace(/\s+/g, ' ').trim() : 'Ë©≥Á¥∞Êú™Ë®≠ÂÆö';
            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';

            let ledger = null;
            let count = 0;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  const match = (comment.body || '').match(/count:\s*(\d+)/i);
                  if (match) {
                    const parsed = Number.parseInt(match[1], 10);
                    if (Number.isFinite(parsed)) {
                      count = parsed;
                    }
                  }
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to read failure ledger comment: ${error}`);
            }

            count += 1;
            const nowIso = new Date().toISOString();
            const bodyLines = [
              marker,
              `count: ${count}`,
              `last_failure: ${nowIso}`,
              `reason: ${compactReason}`,
            ];
            const ledgerBody = bodyLines.join('\n');

            try {
              if (ledger) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: ledger.id, body: ledgerBody });
                core.info(`Updated failure ledger comment (${ledger.id}) to ${count}.`);
              } else {
                ledger = await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: ledgerBody });
                core.info(`Created failure ledger comment (${ledger.id}) with count ${count}.`);
              }
            } catch (error) {
              core.warning(`Failed to update failure ledger comment: ${error}`);
            }

            if (compactReason) {
              core.info(`Recorded failure reason: ${compactReason}`);
            }

            let escalated = false;
            if (threshold > 0 && count >= threshold) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: 'B60205',
                    description: 'Workorder automation suspended after repeated failures',
                  });
                  core.info(`Created escalation label '${labelName}'.`);
                } else {
                  core.warning(`Failed to verify escalation label '${labelName}': ${error}`);
                }
              }

              let hasLabel = false;
              try {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issueNumber });
                hasLabel = (pr.data.labels || []).some((label) => label?.name === labelName);
              } catch (error) {
                core.warning(`Failed to fetch PR #${issueNumber} for label check: ${error}`);
              }

              if (!hasLabel) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [labelName] });
                  hasLabel = true;
                  core.info(`Applied escalation label '${labelName}' to PR #${issueNumber}.`);
                } catch (error) {
                  core.warning(`Failed to add escalation label '${labelName}': ${error}`);
                }
              }

              if (hasLabel) {
                if (count === threshold) {
                  let message = `‚ö†Ô∏è workorder-ready „ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü„ÄÇÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞„ÅåÈñæÂÄ§ (${threshold}) „Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ\n`;
                  message += `- ÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞: ${count}\n`;
                  if (rawReason) {
                    message += `- ÊúÄÂæå„ÅÆÂ§±ÊïóÁêÜÁî±: ${rawReason.trim()}\n`;
                  }
                  message += `- ÂØæÂøú: ÂéüÂõ†„ÇíËß£Ê∂à„Åó„ÄÅ„É©„Éô„É´ '${labelName}' „ÇíÂ§ñ„Åó„Å¶„Åã„ÇâÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
                  if (mention) {
                    message = `${mention}\n\n${message}`;
                  }
                  try {
                    await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: message });
                  } catch (error) {
                    core.warning(`Failed to create escalation comment: ${error}`);
                  }
                }
                escalated = true;
              }
            }

            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`PR #${issueNumber} failure count: ${count}${threshold > 0 ? ` / threshold ${threshold}` : ''}.`, true)
              .write();

            if (!escalated) {
              core.info(`Recorded failure ${count} (threshold ${threshold || 'disabled'}).`);
            }
