name: workorder-ready

on:
  pull_request_target:
    types: [labeled]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Source pull request number (optional)'
        required: false

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  dispatch_notice:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "::notice title=workorder-ready::workflow_dispatch „É´„Éº„Éà„ÅØÊ§úË®ºÂ∞ÇÁî®„Åß„Åô„ÄÇPR„Ç¨„Éº„Éâ„Å® WO-12 ÊÆµÈöé„ÉÜ„Çπ„Éà„ÅØÊó¢ÂÆö„Åß„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„Åæ„Åô„ÄÇ"

  ready:
    name: workorder-ready
    if: >-
      github.event_name == 'pull_request_target' &&
      github.event.action == 'labeled' &&
      github.event.label.name == 'plan:sync'
    env:
      WORKORDER_ALLOWED_PATHS: ${{ vars.WORKORDER_ALLOWED_PATHS || '' }}
      WORKORDER_BLOCKED_PATHS: ${{ vars.WORKORDER_BLOCKED_PATHS || 'alembic/**,infra/**,migrations/**' }}
      WORKORDER_MAX_TASK_LINES: ${{ vars.WORKORDER_MAX_TASK_LINES || '80' }}
      WORKORDER_MAX_PR_LINES: ${{ vars.WORKORDER_MAX_PR_LINES || '120' }}
      WORKORDER_MAX_FILE_LINES: ${{ vars.WORKORDER_MAX_FILE_LINES || '80' }}
      WORKORDER_MAX_TOTAL_LINES: ${{ vars.WORKORDER_MAX_TOTAL_LINES || '180' }}
      WORKORDER_MAX_LINES_PER_ITER: ${{ vars.WORKORDER_MAX_LINES_PER_ITER || '60' }}
      WORKORDER_MAX_ITERATIONS: ${{ vars.WORKORDER_MAX_ITERATIONS || '3' }}
      WORKORDER_MAX_CHANGED_FILES: ${{ vars.WORKORDER_MAX_CHANGED_FILES || '6' }}
      WORKORDER_MAX_AUTO_PRS: ${{ vars.WORKORDER_MAX_AUTO_PRS || vars.WORKORDER_MAX_OPEN_AUTOMATION_PRS || '2' }}
      WORKORDER_RUN_REPORT: tmp/workorder_limits_report.json
      WORKORDER_FAILURE_REASON: 'unknown'
      WORKORDER_FAIL_THRESHOLD: ${{ vars.WORKORDER_FAIL_THRESHOLD || '2' }}
      WORKORDER_ESCALATION_LABEL: ${{ vars.WORKORDER_ESCALATION_LABEL || 'workorder:suspended' }}
      WORKORDER_ESCALATION_MENTION: ${{ vars.WORKORDER_ESCALATION_MENTION || '' }}
      WORKORDER_AUDIT_LOG_PATH: docs/agile/workorder-audit.log
      WORKORDER_TESTS_LOG_DIR: .workorder-tests-logs
      WORKORDER_TESTS_SUMMARY: .workorder-tests-logs/summary.json
    concurrency:
      group: workorder-ready-${{ github.event.pull_request.number || github.ref_name || github.run_id }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - name: Resolve run context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const set = (key, value) => core.setOutput(key, value ?? '');
            const event = context.eventName;
            const currentSha = context.sha || '';

            if (event !== 'pull_request_target') {
              set('should_run', 'false');
              set('reason', 'workorder-ready: pull_request_target(labeled) ‰ª•Â§ñ„ÅØÂÆüË°å„Åó„Åæ„Åõ„Çì');
              set('guard_ref', currentSha);
              set('source_sha', currentSha);
              return;
            }

            const pr = context.payload?.pull_request;
            const action = context.payload?.action;
            const label = context.payload?.label?.name;
            if (!pr || action !== 'labeled' || label !== 'plan:sync') {
              set('should_run', 'false');
              set('reason', 'plan:sync „É©„Éô„É´‰ªò‰∏é„Ç§„Éô„É≥„Éà‰ª•Â§ñ„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô');
              set('guard_ref', currentSha);
              set('source_sha', currentSha);
              return;
            }

            if ((pr.head?.ref || '').trim() === 'docs-sync/workorder') {
              set('should_run', 'false');
              set('reason', 'docs-sync/workorder self-trigger blocked');
              set('source_pr', String(pr.number));
              set('guard_ref', currentSha);
              set('source_sha', currentSha);
              return;
            }

            const planBranch = 'docs-sync/plan';
            const guardRef = pr.head?.sha || currentSha;
            set('should_run', 'true');
            set('checkout_ref', `refs/heads/${planBranch}`);
            set('plan_branch', planBranch);
            set('pr_base', pr.base?.ref || 'main');
            set('source_pr', String(pr.number));
            set('source_head', pr.head?.ref || '');
            set('guard_ref', guardRef);
            set('source_sha', guardRef);
            set('trigger', 'plan-sync:pull_request_target');


      - name: Skip (no action required)
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "workorder-ready skipped: ${{ steps.context.outputs.reason || 'condition not met' }}"

      - name: Create GitHub App token
        if: steps.context.outputs.should_run == 'true'
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          owner: ${{ github.repository_owner }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Checkout target revision
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Configure git user
        if: steps.context.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create workorder branch
        if: steps.context.outputs.should_run == 'true'
        run: |
          git checkout -B docs-sync/workorder

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: steps.context.outputs.should_run == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install PyYAML==6.0.2

      - name: Sync workorder metadata
        if: steps.context.outputs.should_run == 'true'
        id: sync
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_cli ready

      - name: Show workorder_sync_plan
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -f workorder_sync_plan.json ]; then
            cat workorder_sync_plan.json
          fi

      - name: Prepare guard script
        if: steps.context.outputs.should_run == 'true'
        id: guard-script
        run: |
          set -euo pipefail
          mkdir -p tmp
          ref="${{ steps.context.outputs.guard_ref || '' }}"
          if [ -n "$ref" ]; then
            git fetch --no-tags --depth=1 origin "$ref"
            git show "$ref":scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "Failed to load scripts/workorder_guard.py from $ref" >&2
              exit 1
            }
          else
            git show HEAD:scripts/workorder_guard.py > tmp/workorder_guard.py || {
              echo "scripts/workorder_guard.py not found in current ref" >&2
              exit 1
            }
          fi
          echo "script_path=$(pwd)/tmp/workorder_guard.py" >> "$GITHUB_OUTPUT"

      - name: Run workorder guard
        if: steps.context.outputs.should_run == 'true'
        id: guard
        continue-on-error: true
        run: |
          set -euo pipefail
          python3 "${{ steps.guard-script.outputs.script_path }}"

      - name: Parse guard status
        if: steps.context.outputs.should_run == 'true'
        id: guard-status
        run: |
          set -euo pipefail
          if [ -n "${WORKORDER_RUN_REPORT:-}" ] && [ -f "${WORKORDER_RUN_REPORT}" ]; then
            python3 -m scripts.workorder_ready --guard-report "${WORKORDER_RUN_REPORT}" --write-guard-outputs
          else
            python3 -m scripts.workorder_ready --write-guard-outputs
          fi

      - name: Fail when disallowed hides limit breaches
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'disallowed' && steps.guard-status.outputs.limit_exceeded == 'true'
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const message = 'üõë workorder-ready stopped: disallowed paths were detected together with guard limit violations. ‰øÆÊ≠£Âæå„Å´ÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No source PR available to attach combined failure comment.');
            }
            core.setFailed(message);

      - name: Reset disallowed paths
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'disallowed'
        run: |
          set -euo pipefail
          if [ -n "${WORKORDER_RUN_REPORT:-}" ] && [ -f "${WORKORDER_RUN_REPORT}" ]; then
            python3 -m scripts.workorder_ready --guard-report "${WORKORDER_RUN_REPORT}" --reset-disallowed
          fi

      - name: Record audit log entry
        if: steps.context.outputs.should_run == 'true'
        id: audit
        env:
          GUARD_STATUS: ${{ steps.guard-status.outputs.status || 'unknown' }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          SOURCE_HEAD: ${{ steps.context.outputs.source_head }}
          PR_BASE: ${{ steps.context.outputs.pr_base }}
          TRIGGER: ${{ steps.context.outputs.trigger }}
        run: |
          set -euo pipefail
          append_flag=""
          case "${GUARD_STATUS}" in
            ok|no_changes|disallowed)
              ;;
            *)
              append_flag="--skip-append"
              ;;
          esac
          cmd=(
            python3 -m scripts.workorder_audit
            --trigger "${TRIGGER}"
            --source-pr "${SOURCE_PR}"
            --source-head "${SOURCE_HEAD}"
            --pr-base "${PR_BASE}"
            --head-branch "docs-sync/workorder"
            --log "${WORKORDER_AUDIT_LOG_PATH}"
            --artifact tmp/workorder_audit_entry.json
          )
          if [ -n "${append_flag}" ]; then
            cmd+=("${append_flag}")
          fi
          "${cmd[@]}"

      - name: Upload audit log artifact
        if: always() && steps.context.outputs.should_run == 'true' && hashFiles('tmp/workorder_audit_entry.json') != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-audit-entry
          path: tmp/workorder_audit_entry.json

      - name: Handle guard outcome
        if: steps.context.outputs.should_run == 'true' && steps.guard.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ env.WORKORDER_RUN_REPORT }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const fs = require('fs');
            const path = process.env.REPORT_PATH || 'tmp/workorder_limits_report.json';
            let report;
            try {
              report = JSON.parse(fs.readFileSync(path, 'utf-8'));
            } catch (error) {
              core.setFailed(`workorder guard failed but report ${path} could not be read: ${error.message}`);
              return;
            }

            const status = report.status || 'unknown';
            const stats = report.stats || {};
            const limits = report.limits || {};

            const fmtList = (items) => (items && items.length ? items.join(', ') : 'unknown');
            let message;
            if (status === 'disallowed') {
              message = `üõë workorder-ready stopped: disallowed paths detected (${fmtList(report.disallowed_files || [])}).`;
            } else if (status === 'blocked_paths') {
              message = `üõë workorder-ready stopped: blocked paths detected (${fmtList(report.blocked_files || [])}).`;
            } else if (status === 'limit_exceeded') {
              const reasons = [];
              for (const item of report.file_over_limit || []) {
                reasons.push(`${item.path} (${item.total}/${item.limit})`);
              }
              if (report.total_over_limit) {
                const actual = stats.total_lines ?? 'unknown';
                const limit = limits.max_total_changed_lines ?? (limits.max_changed_lines || {}).per_pr ?? 'unknown';
                reasons.push(`total lines ${actual}/${limit}`);
              }
              if (report.file_count_over_limit) {
                const actualFiles = stats.file_count ?? 'unknown';
                const limitFiles = limits.max_changed_files ?? 'unknown';
                reasons.push(`file count ${actualFiles}/${limitFiles}`);
              }
              const detail = reasons.length ? reasons.join('; ') : 'limit exceeded';
              message = `üõë workorder-ready stopped: guard limits hit (${detail}).`;
            } else {
              message = `üõë workorder-ready stopped: guard status ${status}.`;
            }

            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No source PR available to attach guard failure comment.');
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', message);
            core.setFailed(message);

      - name: Upload guard report
        if: always() && steps.context.outputs.should_run == 'true' && hashFiles(env.WORKORDER_RUN_REPORT) != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-limits-report
          path: ${{ env.WORKORDER_RUN_REPORT }}

      - name: Detect workorder changes
        if: steps.context.outputs.should_run == 'true'
        id: changes
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/agile/workorder.md workorder_sync_plan.json "$WORKORDER_AUDIT_LOG_PATH"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Evaluate WO-12 gate
        if: steps.context.outputs.should_run == 'true'
        id: acceptance_gate
        uses: actions/github-script@v7
        env:
          GUARD_STATUS: ${{ steps.guard-status.outputs.status || '' }}
          HAS_DIFF: ${{ steps.changes.outputs.changed || 'false' }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr || '' }}
        with:
          script: |
            const guardOk = process.env.GUARD_STATUS === 'ok';
            const hasDiff = process.env.HAS_DIFF === 'true';
            const prNumber = (process.env.SOURCE_PR || '').trim();
            const event = context.eventName;
            const action = context.payload?.action || '';
            const allowedEvent = event === 'workflow_call' || (event === 'pull_request_target' && action === 'labeled');
            const shouldRun = guardOk && hasDiff && allowedEvent && prNumber;
            const reasons = [];
            if (!guardOk) reasons.push('guard_status');
            if (!hasDiff) reasons.push('no_diff');
            if (!prNumber) reasons.push('missing_pr');
            if (!(event === 'workflow_dispatch') && !allowedEvent) {
              reasons.push(`event:${event}/${action}`);
            }
            core.setOutput('should_run_tests', shouldRun ? 'true' : 'false');
            core.setOutput('reason', reasons.join(',') || '');
            if (event === 'workflow_dispatch') {
              core.notice('workflow_dispatch „É´„Éº„Éà„Åß„ÅØ WO-12 ÊÆµÈöé„ÉÜ„Çπ„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
            } else if (!shouldRun) {
              core.info(`WO-12 tests skipped: ${reasons.join(', ') || 'condition not met'}`);
            }

      - name: WO-12 skip notice
        if: steps.context.outputs.should_run == 'true' && steps.acceptance_gate.outputs.should_run_tests != 'true'
        run: |
          echo "WO-12 tests skipped: ${{ steps.acceptance_gate.outputs.reason || 'condition not met' }}"

      - name: Prepare WO-12 logs directory
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          mkdir -p "${WORKORDER_TESTS_LOG_DIR}"
          rm -f "${WORKORDER_TESTS_SUMMARY}"

      - name: Enforce automation PR ceiling
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        uses: actions/github-script@v7
        env:
          MAX_AUTO_PRS: ${{ env.WORKORDER_MAX_AUTO_PRS }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const limitRaw = process.env.MAX_AUTO_PRS || '0';
            const limit = Number(limitRaw);
            if (!Number.isFinite(limit) || limit <= 0) {
              core.info(`Automation PR ceiling disabled (max=${limitRaw}).`);
              return;
            }
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 100 });
            const open = prs.data.length;
            if (open >= limit) {
              const message = `üõë workorder-ready stopped: open docs-sync/workorder PRs (${open}/${limit}).`;
              if (process.env.SOURCE_PR) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: Number(process.env.SOURCE_PR),
                  body: message,
                });
              }
              core.exportVariable('WORKORDER_FAILURE_REASON', message);
              core.setFailed(message);
              return;
            }
            core.info(`Open docs-sync/workorder PRs: ${open}/${limit}`);

      - name: Comment no-op result
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true' && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: '‚ÑπÔ∏è workorder-ready „ÇíÂÆüË°å„Åó„Åæ„Åó„Åü„Åå„ÄÅËá™ÂãïÊõ¥Êñ∞„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü (No-Op)„ÄÇ'
            });

      - name: Prepare workorder commit
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true' && (steps.guard-status.outputs.status == 'ok' || steps.guard-status.outputs.status == 'no_changes' || steps.guard-status.outputs.status == 'disallowed')
        id: prepare_workorder
        env:
          GUARD_STATUS: ${{ steps.guard-status.outputs.status || 'unknown' }}
          TRIGGER: ${{ steps.context.outputs.trigger }}
          SOURCE_HEAD: ${{ steps.context.outputs.source_head || '' }}
        run: |
          set -euo pipefail
          git add docs/agile/workorder.md workorder_sync_plan.json "$WORKORDER_AUDIT_LOG_PATH"
          if git diff --cached --quiet; then
            {
              echo "commit_created=false"
              echo "before_sha="
              echo "after_sha="
              echo "body_path="
              echo "snapshot="
              echo "tasks_csv="
            } >> "$GITHUB_OUTPUT"
            echo "No workorder changes to commit"
            exit 0
          fi
          before_sha=$(git rev-parse HEAD)
          commit_msg="chore(workorder): sync workorder AUTO sections"
          if [ "${GUARD_STATUS}" = "disallowed" ]; then
            commit_msg="chore(workorder): record audit (disallowed)"
          elif [ "${GUARD_STATUS}" = "no_changes" ]; then
            commit_msg="chore(workorder): record audit (noop)"
          fi
          git commit -m "$commit_msg"
          after_sha=$(git rev-parse HEAD)
          {
            echo "commit_created=true"
            echo "before_sha=${before_sha}"
            echo "after_sha=${after_sha}"
          } >> "$GITHUB_OUTPUT"
          python3 -m scripts.workorder_ready --plan-json workorder_sync_plan.json --trigger "${TRIGGER}" --source-head "${SOURCE_HEAD}"
          echo "Prepared workorder commit ${after_sha}"

      - name: Capture workorder commit SHAs
        if: steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true'
        id: record_commit_sha
        env:
          BEFORE_SHA: ${{ steps.prepare_workorder.outputs.before_sha || '' }}
          AFTER_SHA: ${{ steps.prepare_workorder.outputs.after_sha || '' }}
        run: |
          set -euo pipefail
          before="$BEFORE_SHA"
          after="$AFTER_SHA"
          if [ -z "$before" ]; then
            before=$(git rev-parse HEAD^)
          fi
          if [ -z "$after" ]; then
            after=$(git rev-parse HEAD)
          fi
          {
            echo "before=$before"
            echo "after=$after"
          } >> "$GITHUB_OUTPUT"

      - name: Setup Node for acceptance tests
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true'
        working-directory: frontend
        run: |
          set -euo pipefail
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install --no-audit --no-fund
          fi

      - name: Run WO-12 smoke checks
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true'
        id: wo12_smoke
        continue-on-error: true
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_tests run --phase smoke --summary "${WORKORDER_TESTS_SUMMARY}" --logs-dir "${WORKORDER_TESTS_LOG_DIR}"

      - name: Run WO-12 unit checks
        if: steps.context.outputs.should_run == 'true' && steps.guard-status.outputs.status == 'ok' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true' && steps.wo12_smoke.outcome == 'success'
        id: wo12_unit
        continue-on-error: true
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_tests run --phase unit --summary "${WORKORDER_TESTS_SUMMARY}" --logs-dir "${WORKORDER_TESTS_LOG_DIR}"

      - name: Analyse acceptance summary
        if: steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true'
        id: acceptance_summary
        env:
          SUMMARY_PATH: ${{ env.WORKORDER_TESTS_SUMMARY }}
        run: |
          set -euo pipefail
          summary_path="${SUMMARY_PATH}"
          if [ ! -f "$summary_path" ]; then
            {
              echo "status=error"
              echo "summary_path=$summary_path"
              echo "failed_stage="
              echo "failed_check="
              echo "failed_command="
              echo "log_dir="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
          python3 -m scripts.workorder_ready --summary "$summary_path"

      - name: Upload acceptance logs
        if: always() && steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true' && hashFiles(format('{0}/**', env.WORKORDER_TESTS_LOG_DIR)) != ''
        uses: actions/upload-artifact@v4
        with:
          name: workorder-tests-logs
          path: ${{ env.WORKORDER_TESTS_LOG_DIR }}

      - name: Comment acceptance failure
        if: steps.context.outputs.should_run == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure' && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          FAILED_STAGE: ${{ steps.acceptance_summary.outputs.failed_stage }}
          FAILED_CHECK: ${{ steps.acceptance_summary.outputs.failed_check }}
          FAILED_COMMAND: ${{ steps.acceptance_summary.outputs.failed_command }}
          LOG_DIR: ${{ steps.acceptance_summary.outputs.log_dir }}
          SUMMARY_PATH: ${{ steps.acceptance_summary.outputs.summary_path }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const stage = process.env.FAILED_STAGE || 'unknown';
            const check = process.env.FAILED_CHECK || 'unknown';
            const command = process.env.FAILED_COMMAND || '';
            const logDir = process.env.LOG_DIR || process.env.WORKORDER_TESTS_LOG_DIR || '';
            const summaryPath = process.env.SUMMARY_PATH || process.env.WORKORDER_TESTS_SUMMARY || '';
            let body = 'üõë workorder-ready acceptance tests failed.\n';
            body += `- Stage: ${stage}\n`;
            body += `- Check: ${check}\n`;
            if (command) {
              body += `- Command: \`${command}\`\n`;
            }
            if (logDir) {
              body += `- Logs: ${logDir} (artifact: workorder-tests-logs)\n`;
            }
            if (summaryPath) {
              body += `- Summary: ${summaryPath}\n`;
            }
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body,
            });
            const label = command ? `${check} (${stage})` : (check || stage);
            core.exportVariable('WORKORDER_FAILURE_REASON', `workorder tests failed: ${label}`);

      - name: Rollback workorder commit
        if: steps.context.outputs.should_run == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure'
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_tests rollback \
            --commit "${{ steps.record_commit_sha.outputs.after || steps.prepare_workorder.outputs.after_sha }}" \
            --to "${{ steps.record_commit_sha.outputs.before || steps.prepare_workorder.outputs.before_sha }}" \
            --logs-dir "${WORKORDER_TESTS_LOG_DIR}"
          echo "Rolled back workorder commit due to failed acceptance tests"

      - name: Fail due to acceptance failure
        if: steps.context.outputs.should_run == 'true' && steps.acceptance_gate.outputs.should_run_tests == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && steps.acceptance_summary.outputs.status == 'failure'
        run: |
          echo "::error::workorder acceptance tests failed"
          exit 1

      - name: Push workorder branch
        id: push_workorder
        if: steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && (
          steps.guard-status.outputs.status != 'ok' ||
          steps.acceptance_gate.outputs.should_run_tests != 'true' ||
          (steps.guard-status.outputs.status == 'ok' && steps.acceptance_summary.outputs.status == 'success')
        )
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
          BODY_PATH: ${{ steps.prepare_workorder.outputs.body_path }}
        run: |
          set -euo pipefail
          git push --force-with-lease origin docs-sync/workorder
          body_path="${BODY_PATH}"
          if [ -z "$body_path" ] || [ ! -f "$body_path" ]; then
            echo "body_path=" >> "$GITHUB_OUTPUT"
          else
            echo "body_path=$body_path" >> "$GITHUB_OUTPUT"
          fi
          echo "pushed=true" >> "$GITHUB_OUTPUT"

      - name: Ensure workorder draft PR
        id: sync_pr
        if: steps.context.outputs.should_run == 'true' && steps.prepare_workorder.outputs.commit_created == 'true' && (
          steps.guard-status.outputs.status != 'ok' ||
          steps.acceptance_gate.outputs.should_run_tests != 'true' ||
          (steps.guard-status.outputs.status == 'ok' && steps.acceptance_summary.outputs.status == 'success')
        ) && steps.push_workorder.outputs.body_path != ''
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
          BODY_PATH: ${{ steps.push_workorder.outputs.body_path }}
          PR_BASE: ${{ steps.context.outputs.pr_base }}
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        run: |
          set -euo pipefail
          python3 -m scripts.workorder_ready --ensure-pr --body-path "${BODY_PATH}" --base "${PR_BASE}" --source-pr "${SOURCE_PR}"

      - name: Comment PR link
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.source_pr != '' && steps.prepare_workorder.outputs.commit_created == 'true' && (
          steps.guard-status.outputs.status != 'ok' ||
          steps.acceptance_gate.outputs.should_run_tests != 'true' ||
          (steps.guard-status.outputs.status == 'ok' && steps.acceptance_summary.outputs.status == 'success')
        )
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = `${owner}:docs-sync/workorder`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (!prs.data.length) {
              console.log('No workorder-ready PR to comment');
              return;
            }
            const url = prs.data[0].html_url;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: `üõ†Ô∏è workorder-ready: ${url}`,
            });

      - name: Note no-op in logs
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true'
        run: echo "workorder-ready completed without changes"

      - name: Remove failed guard label
        if: steps.context.outputs.should_run == 'true' && success() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            const label = 'failed guard';
            if (!issueNumber) {
              core.info('failed guard label removal skipped: missing PR number');
              return;
            }
            try {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: label });
              core.info(`Removed '${label}' label from PR #${issueNumber}.`);
            } catch (error) {
              if (error.status !== 404) {
                core.warning(`Failed to remove '${label}' label: ${error}`);
              }
            }

      - name: Reset failure ledger
        if: steps.context.outputs.should_run == 'true' && success() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.info('Reset skipped: missing source PR number.');
              return;
            }

            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';
            let ledger = null;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to inspect failure ledger: ${error}`);
            }

            if (ledger) {
              try {
                await github.rest.issues.deleteComment({ owner, repo, comment_id: ledger.id });
                core.info(`Deleted failure ledger comment (${ledger.id}).`);
              } catch (error) {
                core.warning(`Failed to delete ledger comment: ${error}`);
              }
            }

            const labelName = (process.env.ESCALATION_LABEL || '').trim();
            if (labelName) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: labelName });
                core.info(`Removed escalation label '${labelName}'.`);
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Escalation label '${labelName}' not present on PR #${issueNumber}.`);
                } else {
                  core.warning(`Failed to remove escalation label '${labelName}': ${error}`);
                }
              }
            }

            core.exportVariable('WORKORDER_FAILURE_REASON', '');
            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`ÈÄ£Á∂öÂ§±Êïó„Ç´„Ç¶„É≥„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü (PR #${issueNumber}).`, true)
              .write();

      - name: Mark failed guard label
        if: failure() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            const label = 'failed guard';
            if (!issueNumber) {
              core.warning('failed guard label skipped: missing PR number');
              return;
            }
            try {
              await github.rest.issues.getLabel({ owner, repo, name: label });
            } catch (error) {
              if (error.status === 404) {
                await github.rest.issues.createLabel({ owner, repo, name: label, color: 'B60205', description: 'workorder automation failed guard/tests' });
              } else {
                core.warning(`Failed to verify '${label}' label: ${error}`);
              }
            }
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [label] });
            } catch (error) {
              if (error.status !== 422) {
                core.warning(`Failed to add '${label}' label: ${error}`);
              }
            }

      - name: Record failure ledger
        if: failure() && steps.context.outputs.source_pr != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.source_pr }}
          FAILURE_REASON: ${{ env.WORKORDER_FAILURE_REASON }}
          FAIL_THRESHOLD: ${{ env.WORKORDER_FAIL_THRESHOLD }}
          ESCALATION_LABEL: ${{ env.WORKORDER_ESCALATION_LABEL }}
          ESCALATION_MENTION: ${{ env.WORKORDER_ESCALATION_MENTION }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.SOURCE_PR);
            if (!issueNumber) {
              core.warning('Failure ledger skipped: missing source PR number.');
              return;
            }

            const threshold = Number.parseInt(process.env.FAIL_THRESHOLD || '0', 10);
            const labelName = (process.env.ESCALATION_LABEL || 'workorder:suspended').trim();
            const mention = (process.env.ESCALATION_MENTION || '').trim();
            const rawReason = process.env.FAILURE_REASON || '';
            const compactReason = rawReason ? rawReason.replace(/\s+/g, ' ').trim() : 'Ë©≥Á¥∞Êú™Ë®≠ÂÆö';
            const marker = '<!-- workorder-ready:failure-counter -->';
            const botLogin = 'github-actions[bot]';

            let ledger = null;
            let count = 0;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              for (let i = comments.length - 1; i >= 0; i -= 1) {
                const comment = comments[i];
                if ((comment.body || '').includes(marker) && comment.user?.login === botLogin) {
                  ledger = comment;
                  const match = (comment.body || '').match(/count:\s*(\d+)/i);
                  if (match) {
                    const parsed = Number.parseInt(match[1], 10);
                    if (Number.isFinite(parsed)) {
                      count = parsed;
                    }
                  }
                  break;
                }
              }
            } catch (error) {
              core.warning(`Failed to read failure ledger comment: ${error}`);
            }

            count += 1;
            const nowIso = new Date().toISOString();
            const bodyLines = [
              marker,
              `count: ${count}`,
              `last_failure: ${nowIso}`,
              `reason: ${compactReason}`,
            ];
            const ledgerBody = bodyLines.join('\n');

            try {
              if (ledger) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: ledger.id, body: ledgerBody });
                core.info(`Updated failure ledger comment (${ledger.id}) to ${count}.`);
              } else {
                ledger = await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: ledgerBody });
                core.info(`Created failure ledger comment (${ledger.id}) with count ${count}.`);
              }
            } catch (error) {
              core.warning(`Failed to update failure ledger comment: ${error}`);
            }

            if (compactReason) {
              core.info(`Recorded failure reason: ${compactReason}`);
            }

            let escalated = false;
            if (threshold > 0 && count >= threshold) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: 'B60205',
                    description: 'Workorder automation suspended after repeated failures',
                  });
                  core.info(`Created escalation label '${labelName}'.`);
                } else {
                  core.warning(`Failed to verify escalation label '${labelName}': ${error}`);
                }
              }

              let hasLabel = false;
              try {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issueNumber });
                hasLabel = (pr.data.labels || []).some((label) => label?.name === labelName);
              } catch (error) {
                core.warning(`Failed to fetch PR #${issueNumber} for label check: ${error}`);
              }

              if (!hasLabel) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [labelName] });
                  hasLabel = true;
                  core.info(`Applied escalation label '${labelName}' to PR #${issueNumber}.`);
                } catch (error) {
                  core.warning(`Failed to add escalation label '${labelName}': ${error}`);
                }
              }

              if (hasLabel) {
                if (count === threshold) {
                  let message = `‚ö†Ô∏è workorder-ready „ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü„ÄÇÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞„ÅåÈñæÂÄ§ (${threshold}) „Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ\n`;
                  message += `- ÈÄ£Á∂öÂ§±ÊïóÂõûÊï∞: ${count}\n`;
                  if (rawReason) {
                    message += `- ÊúÄÂæå„ÅÆÂ§±ÊïóÁêÜÁî±: ${rawReason.trim()}\n`;
                  }
                  message += `- ÂØæÂøú: ÂéüÂõ†„ÇíËß£Ê∂à„Åó„ÄÅ„É©„Éô„É´ '${labelName}' „ÇíÂ§ñ„Åó„Å¶„Åã„ÇâÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
                  if (mention) {
                    message = `${mention}\n\n${message}`;
                  }
                  try {
                    await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: message });
                  } catch (error) {
                    core.warning(`Failed to create escalation comment: ${error}`);
                  }
                }
                escalated = true;
              }
            }

            await core.summary
              .addHeading('workorder-ready failure ledger', 3)
              .addRaw(`PR #${issueNumber} failure count: ${count}${threshold > 0 ? ` / threshold ${threshold}` : ''}.`, true)
              .write();

            if (!escalated) {
              core.info(`Recorded failure ${count} (threshold ${threshold || 'disabled'}).`);
            }
