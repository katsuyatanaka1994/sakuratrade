name: pr-label-cleanup

on:
  schedule:
    - cron: '0 4 * * *'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  DS16_MODE: ${{ vars.DS16_MODE || 'observe' }}

jobs:
  sweep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - uses: actions/github-script@v7
        with:
          script: |
            const path = require('path');
            const helperPath = path.join(process.env.GITHUB_WORKSPACE, '.github', 'scripts', 'ds27-check-state.js');
            const { evaluateChecks } = require(helperPath);

            const mode = (process.env.DS16_MODE || 'observe').toLowerCase();
            if (mode !== 'observe') {
              core.info(`DS16 cleanup skips because mode=${mode}`);
              return;
            }

            const { owner, repo } = context.repo;
            const LIMIT = 30;
            let processed = 0;
            let cleaned = 0;

            const pulls = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: 'open',
              per_page: 50,
            });

            const needsReview = pulls.filter((pr) => {
              const labels = (pr.labels || []).map((l) => l.name);
              return labels.includes('docs:invalid') || labels.includes('triage:urgent');
            });

            core.info(`DS16 cleanup: evaluating ${needsReview.length} open PRs with docs labels`);

            for (const pr of needsReview) {
              if (processed >= LIMIT) {
                core.info(`DS16 cleanup: reached processing limit (${LIMIT}); stopping`);
                break;
              }
              processed += 1;

              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner,
                repo,
                pull_number: pr.number,
                per_page: 100,
              });
              const changedDocs = files.some((file) => (file.filename || '').startsWith('docs/'));

              if (!changedDocs) {
                await removeDocsLabels(pr.number);
                cleaned += 1;
                core.info(`PR #${pr.number}: no docs changes detected; labels removed`);
                continue;
              }

              const sha = pr.head?.sha;
              if (!sha) {
                core.info(`PR #${pr.number}: missing head SHA; skipping`);
                continue;
              }

              let evaluation;
              try {
                evaluation = await evaluateChecks({
                  github,
                  owner,
                  repo,
                  sha,
                  requiredChecks: ['docs-index-validate','nfr-xref'],
                });
              } catch (error) {
                core.warning(`PR #${pr.number}: evaluation failed (${error?.message || error})`);
                continue;
              }

              if (evaluation?.allSuccess) {
                await removeDocsLabels(pr.number);
                cleaned += 1;
                core.info(`PR #${pr.number}: docs checks all green; labels removed`);
              } else {
                core.info(`PR #${pr.number}: docs checks not green; keeping labels`);
              }
            }

            core.info(`DS16 cleanup summary: processed=${processed}, cleaned=${cleaned}`);
            await core.summary.addHeading('DS16 cleanup summary');
            await core.summary.addRaw(`Processed: ${processed}\\nCleaned: ${cleaned}`);
            await core.summary.write();

            async function removeDocsLabels(issue_number) {
              for (const name of ['docs:invalid', 'triage:urgent']) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
                  core.info(`PR #${issue_number}: removed ${name}`);
                } catch (error) {
                  if (error.status !== 404) {
                    throw error;
                  }
                  core.info(`PR #${issue_number}: ${name} already absent`);
                }
              }
            }
