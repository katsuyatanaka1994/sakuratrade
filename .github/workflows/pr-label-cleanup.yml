name: pr-label-cleanup

on:
  schedule:
    - cron: '0 4 * * *'
  workflow_dispatch:
    inputs:
      limit:
        description: "Max PRs to process"
        default: "30"
      dry_run:
        description: "No label removal (log only)"
        default: "false"

concurrency:
  group: pr-label-cleanup
  cancel-in-progress: true

jobs:
  sweep:
    env:
      DS16_MODE: ${{ vars.DS16_MODE || 'observe' }}
    if: ${{ (vars.DS16_MODE || 'observe') == 'observe' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
      checks: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: Checkout guardlib main
        uses: actions/checkout@v4
        with: 
          repository: ${{ github.repository }}
          ref: main
          path: guardlib
          fetch-depth: 1
      - name: Echo dispatch meta
        env:
          E_LIMIT: ${{ github.event.inputs.limit || '30' }}
          E_DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "cleanup dispatch: mode=${DS16_MODE} limit=${E_LIMIT} dry_run=${E_DRY_RUN}"
      - name: Run label cleanup
        uses: actions/github-script@v7
        env:
          INPUT_LIMIT: ${{ github.event.inputs.limit || '30' }}
          INPUT_DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const path = require('path');
            const guardLibScript = path.join(process.env.GITHUB_WORKSPACE, 'guardlib', '.github', 'scripts', 'ds27-check-state.js');
            const { evaluateChecks } = require(guardLibScript);

            const limitInput = process.env.INPUT_LIMIT || '30';
            let limit = parseInt(limitInput, 10);
            if (!Number.isFinite(limit) || limit <= 0) {
              core.warning(`Invalid limit input (${limitInput}); defaulting to 30`);
              limit = 30;
            }
            const dryRun = (process.env.INPUT_DRY_RUN || 'false').toLowerCase() === 'true';

            const TARGET_LABELS = ['docs:invalid', 'triage:urgent'];
            const REQUIRED_DOC_CHECKS = ['docs-index-validate', 'nfr-xref'];
            const THROTTLE_MS = 300;
            const { owner, repo } = context.repo;

            const candidatePrNumbers = await fetchCandidatePrNumbers();
            core.info(`DS16 cleanup: ${candidatePrNumbers.length} candidate PRs (limit ${limit}) dryRun=${dryRun}`);

            let processed = 0;
            let cleaned = 0;
            const warnings = [];

            for (const prNumber of candidatePrNumbers) {
              if (processed >= limit) {
                core.info(`DS16 cleanup: reached processing limit (${limit}); stopping`);
                break;
              }
              processed += 1;

              try {
                let sha;
                try {
                  const prData = await withRetry(() => github.rest.pulls.get({ owner, repo, pull_number: prNumber }));
                  const isFork = prData.data?.head?.repo?.fork;
                  if (isFork) {
                    const msg = `PR #${prNumber}: fork PR; skip cleanup`;
                    warnings.push(msg);
                    core.info(msg);
                    await sleep(THROTTLE_MS);
                    continue;
                  }
                  sha = prData.data?.head?.sha;
                } catch (error) {
                  throw new Error(`failed to refresh PR head (${error?.message || error})`);
                }

                if (!sha) {
                  const message = `PR #${prNumber}: missing head SHA; skipped`;
                  warnings.push(message);
                  core.warning(`${message}`);
                  await sleep(THROTTLE_MS);
                  continue;
                }

                let files;
                try {
                  files = await withRetry(() => github.paginate(
                    github.rest.pulls.listFiles,
                    { owner, repo, pull_number: prNumber, per_page: 100 },
                  ));
                } catch (e) {
                  const msg = `PR #${prNumber}: listFiles failed (${e.message || e}); skip cleanup`;
                  warnings.push(msg);
                  core.warning(msg);
                  await sleep(THROTTLE_MS);
                  continue; // avoid accidental removal; do not default to nodocs
                }
                const changedDocs = (files || []).some((file) => (file.filename || '').startsWith('docs/'));

                if (!changedDocs) {
                  if (dryRun) {
                    core.info(`PR #${prNumber}: no docs changes detected; dry-run so labels stay`);
                  } else {
                    await removeDocsLabels(prNumber);
                    cleaned += 1;
                    core.info(`PR #${prNumber}: no docs changes detected; labels removed`);
                  }
                  await sleep(THROTTLE_MS);
                  continue;
                }

                const requiredChecks = REQUIRED_DOC_CHECKS;
                let docsChecksGreen = false;
                let checkVerdictSource = 'head';
                try {
                  const evaluation = await evaluateChecks({
                    github,
                    owner,
                    repo,
                    sha,
                    requiredChecks,
                  });
                  const headRuns = evaluation?.runCount ?? 0;
                  const headSuccess = Boolean(evaluation?.allSuccess);
                  const shortSha = (sha || '').toString().substring(0, 7);
                  core.info(`PR #${prNumber}: evaluate on head.sha=${shortSha} runs=${headRuns} allSuccess=${headSuccess}`);
                  docsChecksGreen = headSuccess;

                  if (!docsChecksGreen || headRuns === 0) {
                    const mergeRef = `refs/pull/${prNumber}/merge`;
                    core.info(`PR #${prNumber}: retry evaluateChecks on ${mergeRef}`);
                    const mergeEvaluation = await evaluateChecks({
                      github,
                      owner,
                      repo,
                      sha: mergeRef,
                      requiredChecks,
                    });
                    const mergeRuns = mergeEvaluation?.runCount ?? 0;
                    const mergeSuccess = Boolean(mergeEvaluation?.allSuccess);
                    core.info(`PR #${prNumber}: evaluate on ${mergeRef} runs=${mergeRuns} allSuccess=${mergeSuccess}`);
                    docsChecksGreen = mergeSuccess;
                    if (docsChecksGreen) {
                      checkVerdictSource = 'merge';
                    }
                  }
                } catch (error) {
                  core.warning(`PR #${prNumber}: checks API failed (${error?.message || error}); fallback to combined status`);
                  try {
                    docsChecksGreen = await isDocsGreenViaStatus(sha, requiredChecks);
                    if (docsChecksGreen) {
                      checkVerdictSource = 'status';
                    }
                  } catch (statusError) {
                    throw new Error(`combined status fallback failed (${statusError?.message || statusError})`);
                  }
                }

                if (docsChecksGreen) {
                  const successMessage = checkVerdictSource === 'merge'
                    ? 'merge-ref checks green'
                    : checkVerdictSource === 'status'
                      ? 'combined status indicates docs checks green'
                      : 'docs checks green';
                  if (dryRun) {
                    core.info(`PR #${prNumber}: ${successMessage}; dry-run so labels stay`);
                  } else {
                    await removeDocsLabels(prNumber);
                    cleaned += 1;
                    core.info(`PR #${prNumber}: ${successMessage}; labels removed`);
                  }
                } else {
                  core.info(`PR #${prNumber}: docs checks not green; keeping labels`);
                }
              } catch (error) {
                const message = `PR #${prNumber}: ${error?.message || error}`;
                warnings.push(message);
                core.warning(`${message}; skipped`);
              }

              await sleep(THROTTLE_MS);
            }

            const summaryLines = [
              'DS16 cleanup summary',
              `Processed: ${processed}`,
              `Cleaned: ${cleaned}`,
              `Warnings: ${warnings.length}`,
            ];
            if (warnings.length) {
              summaryLines.push('Warning details:');
              for (const warning of warnings) {
                summaryLines.push(`- ${warning}`);
              }
            }

            await core.summary
              .addHeading('DS16 cleanup summary')
              .addRaw(summaryLines.slice(1).join('\n'))
              .write();

            async function removeDocsLabels(issue_number) {
              for (const name of TARGET_LABELS) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
                  core.info(`PR #${issue_number}: removed ${name}`);
                } catch (error) {
                  if (error.status === 404) {
                    core.info(`PR #${issue_number}: ${name} already absent`);
                    continue;
                  }
                  throw error;
                }
              }
            }

            async function fetchCandidatePrNumbers() {
              const seen = new Set();
              const baseQuery = `repo:${owner}/${repo} is:pr is:open`;
              for (const label of TARGET_LABELS) {
                const query = `${baseQuery} label:"${label}"`;
                const results = await withRetry(() => github.paginate(
                  github.rest.search.issuesAndPullRequests,
                  { q: query, per_page: 100 },
                ));
                for (const item of results || []) {
                  if (item?.number) {
                    seen.add(item.number);
                  }
                }
              }
              return Array.from(seen).sort((a, b) => a - b);
            }

            async function isDocsGreenViaStatus(sha, requiredChecks) {
              const normalizedRequired = (requiredChecks || [])
                .map((name) => (name || '').toLowerCase())
                .filter(Boolean);
              const result = await withRetry(() =>
                github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha }),
              );
              const statuses = result?.data?.statuses || [];
              const contexts = new Set(statuses.map((status) => (status.context || '').toLowerCase()));
              const allContextsPresent = normalizedRequired.every((name) => contexts.has(name));
              return result?.data?.state === 'success' && allContextsPresent;
            }

            async function withRetry(fn, attempts = 4) {
              let delay = 500;
              for (let i = 0; i < attempts; i += 1) {
                try {
                  return await fn();
                } catch (error) {
                  const status = error?.status;
                  const retriable = [403, 429, 502, 503].includes(status);
                  if (!retriable || i === attempts - 1) {
                    throw error;
                  }
                  core.warning(`Retryable API failure (status=${status || 'unknown'}) retrying in ${delay}ms`);
                  await sleep(delay);
                  delay *= 2;
                }
              }
            }

            function sleep(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms));
            }
