name: plan-sync/Validate

on:
  workflow_dispatch:
    inputs:
      pr:
        description: 'Pull request number to sync (optional)'
        required: false
      branch:
        description: 'Branch to run on when PR is not specified (default: main)'
        required: false
  pull_request_target:
    types: [labeled, opened, reopened, ready_for_review, synchronize]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

defaults:
  run:
    shell: bash

jobs:
  sync:
    name: plan-sync/Validate
    env:
      PLAN_SYNC_ALLOWED_PATHS: ${{ vars.PLAN_SYNC_ALLOWED_PATHS || vars.PLAN_SYNC_ALLOW_GLOBS || 'docs/agile/**,docs/specs/**,docs/tests/**,.github/workflows/**,backend/app/openapi.yaml' }}
      PLAN_SYNC_BLOCKED_PATHS: ${{ vars.PLAN_SYNC_BLOCKED_PATHS || vars.PLAN_SYNC_DENY_GLOBS || 'docs/secrets/**' }}
      PLAN_SYNC_MAX_CHANGED_LINES: ${{ vars.PLAN_SYNC_MAX_CHANGED_LINES || vars.PLAN_SYNC_MAX_LINES || '300' }}
      PLAN_SYNC_MAX_CHANGED_FILES: ${{ vars.PLAN_SYNC_MAX_CHANGED_FILES || vars.PLAN_SYNC_MAX_FILES || '4' }}
      PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS: ${{ vars.PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS || vars.PLAN_SYNC_MAX_AUTO_PRS || '2' }}
      PLAN_SYNC_RUN_REPORT: tmp/plan_limits_report.json
      PLAN_SYNC_AUTO_ENABLED: ${{ vars.PLAN_AUTO || '0' }}
      PLAN_SYNC_AUTO_TARGET_PATHS: ${{ vars.PLAN_SYNC_AUTO_TARGET_PATHS || 'docs/agile/ui-specification.md' }}
      PLAN_SYNC_AUTO_MAX_RUNS_PER_HOUR: ${{ vars.PLAN_SYNC_AUTO_MAX_RUNS_PER_HOUR || '1' }}
      PLAN_SYNC_AUTO_WINDOW_MINUTES: ${{ vars.PLAN_SYNC_AUTO_WINDOW_MINUTES || vars.PLAN_SYNC_AUTO_WINDOW_MIN || '60' }}
    concurrency:
      group: docs-sync-plan-${{ github.event.pull_request.number || github.ref_name || 'manual' }}
      cancel-in-progress: false
    if: |
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request_target' &&
        (
          github.event.action == 'labeled' ||
          contains(fromJson('["opened","reopened","synchronize","ready_for_review"]'), github.event.action)
        )
      ) ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request)
    runs-on: ubuntu-latest
    steps:
      - name: Resolve run context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const event = context.eventName;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const set = (key, value) => core.setOutput(key, value ?? '');

            if (event === 'workflow_dispatch') {
              const prInput = core.getInput('pr');
              const branchInput = core.getInput('branch');
              if (prInput) {
                const prNumber = Number(prInput);
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                set('should_run', 'true');
                set('trigger_mode', 'dispatch');
                set('pr_number', String(prNumber));
                set('checkout_ref', `refs/pull/${prNumber}/head`);
                set('base_ref', pr.data.base.ref);
                set('base_sha', pr.data.base.sha ?? '');
                set('head_ref', pr.data.head.ref);
                return;
              }
              const inferredBranch = branchInput || context.ref.replace('refs/heads/', '');
              set('should_run', 'true');
              set('trigger_mode', 'dispatch');
              set('pr_number', '');
              set('checkout_ref', `refs/heads/${inferredBranch}`);
              set('base_ref', 'main');
              set('base_sha', '');
              set('head_ref', inferredBranch);
              return;
            }

            if (event === 'pull_request_target') {
              const pr = context.payload.pull_request;
              const action = context.payload.action;
              if (!pr) {
                set('should_run', 'false');
                set('reason', 'missing pull request context');
                return;
              }

              const planBranch = 'docs-sync/plan';
              const autoActions = new Set(['opened', 'reopened', 'synchronize', 'ready_for_review']);

              if (action === 'labeled') {
                const label = context.payload.label?.name;
                if (label !== 'plan:sync') {
                  set('should_run', 'false');
                  set('reason', 'label condition not met');
                  return;
                }
                if (pr.head.ref === planBranch) {
                  set('should_run', 'false');
                  set('reason', 'plan branch self-trigger');
                  return;
                }
                set('should_run', 'true');
                set('trigger_mode', 'label');
                set('pr_number', String(pr.number));
                set('checkout_ref', `refs/pull/${pr.number}/head`);
                set('base_ref', pr.base.ref);
                set('base_sha', pr.base.sha ?? '');
                set('head_ref', pr.head.ref);
                return;
              }

              if (!autoActions.has(action)) {
                set('should_run', 'false');
                set('reason', `unsupported pull_request_target action: ${action}`);
                return;
              }

              const autoEnabled = (process.env.PLAN_SYNC_AUTO_ENABLED || '').trim() === '1';
              if (!autoEnabled) {
                set('should_run', 'false');
                set('reason', 'auto trigger disabled (PLAN_AUTO!=1)');
                return;
              }

              if (pr.head.ref === planBranch) {
                set('should_run', 'false');
                set('reason', 'plan branch self-trigger');
                return;
              }

              const skipPattern = /\[skip\s*plan\]/i;
              if (skipPattern.test(pr.title || '') || skipPattern.test(pr.body || '')) {
                set('should_run', 'false');
                set('reason', 'auto trigger skipped by [skip plan]');
                return;
              }

              const owner = context.repo.owner;
              const repo = context.repo.repo;
              const targetPaths = (process.env.PLAN_SYNC_AUTO_TARGET_PATHS || '')
                .split(',')
                .map((item) => item.trim())
                .filter(Boolean);
              if (!targetPaths.length) {
                set('should_run', 'false');
                set('reason', 'auto trigger target paths not configured');
                return;
              }

              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner,
                repo,
                pull_number: pr.number,
                per_page: 100,
              });
              const touched = files.some((file) => targetPaths.includes(file.filename));
              if (!touched) {
                set('should_run', 'false');
                set('reason', 'auto trigger paths not touched');
                return;
              }

              const windowMinutesRaw = Number(process.env.PLAN_SYNC_AUTO_WINDOW_MINUTES || '60');
              const windowMinutes = Number.isFinite(windowMinutesRaw) && windowMinutesRaw > 0 ? windowMinutesRaw : 60;
              const windowMs = windowMinutes * 60 * 1000;
              const maxRunsRaw = Number(process.env.PLAN_SYNC_AUTO_MAX_RUNS_PER_HOUR || '1');
              const maxRuns = Number.isFinite(maxRunsRaw) && maxRunsRaw >= 0 ? maxRunsRaw : 1;
              const tag = '<!-- plan-sync:auto -->';
              let ledgerComment;
              let history = [];

              try {
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: pr.number,
                  per_page: 100,
                });
                ledgerComment = comments.find((comment) => (comment.body || '').startsWith(tag));
                if (ledgerComment) {
                  const raw = ledgerComment.body.slice(tag.length);
                  const payloadLine = raw.split('\n')[0].trim();
                  try {
                    const parsed = payloadLine ? JSON.parse(payloadLine) : {};
                    const timestamps = Array.isArray(parsed)
                      ? parsed
                      : Array.isArray(parsed?.timestamps)
                        ? parsed.timestamps
                        : [];
                    history = timestamps
                      .map((value) => {
                        const date = new Date(value);
                        return Number.isNaN(date.getTime()) ? null : date.toISOString();
                      })
                      .filter(Boolean);
                  } catch (error) {
                    core.warning(`Failed to parse plan auto ledger payload: ${error}`);
                    history = [];
                  }
                }
              } catch (error) {
                core.warning(`Failed to read plan auto ledger comment: ${error}`);
              }

              const now = new Date();
              const cutoff = now.getTime() - windowMs;
              const recentHistory = history
                .map((iso) => new Date(iso))
                .filter((date) => !Number.isNaN(date.getTime()) && date.getTime() >= cutoff)
                .map((date) => date.toISOString());

              if (maxRuns > 0 && recentHistory.length >= maxRuns) {
                set('should_run', 'false');
                set('reason', `auto trigger throttled (${recentHistory.length}/${maxRuns} in ${windowMinutes}m)`);
                return;
              }

              recentHistory.push(now.toISOString());
              set('should_run', 'true');
              set('trigger_mode', 'auto');
              set('pr_number', String(pr.number));
              set('checkout_ref', `refs/pull/${pr.number}/head`);
              set('base_ref', pr.base.ref);
              set('base_sha', pr.base.sha ?? '');
              set('head_ref', pr.head.ref);
              set('auto_history', JSON.stringify({ timestamps: recentHistory }));
              set('auto_comment_id', ledgerComment?.id ? String(ledgerComment.id) : '');
              return;
            }

            if (event === 'issue_comment') {
              const prLink = context.payload.issue.pull_request;
              const body = (context.payload.comment.body || '').trim();
              if (!prLink) {
                set('should_run', 'false');
                set('reason', 'not a PR comment');
                return;
              }
              if (!/^\/plan\s+sync\b/i.test(body)) {
                set('should_run', 'false');
                set('reason', 'no slash command');
                return;
              }
              const actor = context.payload.comment.user?.login;
              if (!actor) {
                set('should_run', 'false');
                set('reason', 'missing commenter');
                return;
              }
              try {
                const permRes = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: actor });
                const permission = permRes.data.permission;
                const allowed = new Set(['admin', 'write', 'maintain']);
                if (!allowed.has(permission)) {
                  set('should_run', 'false');
                  set('reason', `insufficient permissions (${permission})`);
                  return;
                }
              } catch (error) {
                set('should_run', 'false');
                set('reason', 'failed to verify commenter permissions');
                return;
              }

              const prNumber = context.payload.issue.number;
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              if (pr.data.head.ref === 'docs-sync/plan') {
                set('should_run', 'false');
                set('reason', 'plan branch self-trigger');
                return;
              }
              set('should_run', 'true');
              set('trigger_mode', 'slash');
              set('pr_number', String(prNumber));
              set('checkout_ref', `refs/pull/${prNumber}/head`);
              set('base_ref', pr.data.base.ref);
              set('base_sha', pr.data.base.sha ?? '');
              set('head_ref', pr.data.head.ref);
              return;
            }

            set('should_run', 'false');
            set('reason', `unsupported event: ${event}`);

      - name: Skip (no action required)
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "plan-sync skipped: ${{ steps.context.outputs.reason || 'condition not met' }}"

      - name: Record auto trigger window
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.trigger_mode == 'auto'
        uses: actions/github-script@v7
        env:
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
          HISTORY_PAYLOAD: ${{ steps.context.outputs.auto_history }}
          EXISTING_COMMENT_ID: ${{ steps.context.outputs.auto_comment_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = Number(process.env.TARGET_PR);
            if (!issueNumber) {
              core.warning('Auto trigger ledger skipped: missing PR number.');
              return;
            }

            let payload;
            try {
              payload = process.env.HISTORY_PAYLOAD ? JSON.parse(process.env.HISTORY_PAYLOAD) : {};
            } catch (error) {
              core.warning(`Failed to parse auto history payload: ${error}`);
              payload = {};
            }
            const timestamps = Array.isArray(payload)
              ? payload
              : Array.isArray(payload?.timestamps)
                ? payload.timestamps
                : [];

            const tag = '<!-- plan-sync:auto -->';
            const latest = timestamps[timestamps.length - 1] || 'unknown';
            const lines = [
              `${tag}${JSON.stringify({ timestamps })}`,
              'Auto plan-sync trigger ledger',
              `- last: ${latest}`,
              `- count (window): ${timestamps.length}`,
            ];
            const body = lines.join('\n');

            const commentId = process.env.EXISTING_COMMENT_ID;
            if (commentId) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: Number(commentId),
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body,
              });
            }

      - name: Create GitHub App token
        if: steps.context.outputs.should_run == 'true'
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          owner: ${{ github.repository_owner }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Checkout target revision
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Configure git user
        if: steps.context.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Fetch base ref
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.base_ref != ''
        run: |
          git fetch --no-tags --prune --depth=1 origin "${{ steps.context.outputs.base_ref }}" || true
          if [ -n "${{ steps.context.outputs.base_sha }}" ]; then
            git fetch --no-tags --prune --depth=1 origin "${{ steps.context.outputs.base_sha }}" || true
          fi

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install minimal dependencies
        if: steps.context.outputs.should_run == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install PyYAML==6.0.2

      - name: Run plan preflight & apply
        if: steps.context.outputs.should_run == 'true'
        id: plan-run
        continue-on-error: true
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          set -euo pipefail
          python -m scripts.plan_cli preflight
          python -m scripts.plan_cli apply

      - name: Handle guard outcome
        if: steps.context.outputs.should_run == 'true' && steps.plan-run.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ env.PLAN_SYNC_RUN_REPORT }}
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            let payload;
            try {
              payload = JSON.parse(fs.readFileSync(process.env.REPORT_PATH, 'utf-8'));
            } catch (error) {
              core.setFailed(`plan-sync failed but report ${process.env.REPORT_PATH} was not found: ${error}`);
              return;
            }
            const preflight = payload.preflight || {};
            const apply = payload.apply || {};

            let message;
            if (preflight.status === 'blocked_paths') {
              const files = (preflight.blocked_files || []).join(', ');
              message = `🛑 plan-sync stopped: blocked path detected (${files || 'unknown'})`;
            } else if (apply.status === 'limit_exceeded') {
              const type = apply.limit_type === 'lines' ? 'line change limit' : 'file limit';
              const limit = apply.limit_type === 'lines' ? apply.max_lines : apply.max_files;
              const actual = apply.actual ?? 'unknown';
              message = `🛑 plan-sync stopped: ${type} hit (${actual}/${limit}).`;
            }

            if (!message) {
              core.setFailed('plan-sync failed before producing a limit report. Check workflow logs.');
              return;
            }

            if (process.env.TARGET_PR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.TARGET_PR),
                body: message,
              });
            } else {
              core.warning('No PR context available to post guard message.');
            }

            core.setFailed(message);

      - name: Validate plan diff
        if: steps.context.outputs.should_run == 'true'
        id: validate
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p tmp
          args=()
          if [ -n "${{ steps.context.outputs.base_sha }}" ]; then
            args+=("--base-sha" "${{ steps.context.outputs.base_sha }}")
          fi
          python3 scripts/validate-agile-docs "${args[@]}" --manual-diff-report tmp/manual_diff.txt

      - name: Upload manual diff detail
        if: always() && steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure' && hashFiles('tmp/manual_diff.txt') != ''
        uses: actions/upload-artifact@v4
        with:
          name: plan-manual-diff
          path: tmp/manual_diff.txt

      - name: Comment manual diff guidance
        if: always() && steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure' && hashFiles('tmp/manual_diff.txt') != '' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const diff = fs.readFileSync('tmp/manual_diff.txt', 'utf-8');
            const truncated = diff.length > 6000 ? diff.slice(0, 6000) + '\n...[truncated]...' : diff;
            const body = [
              '⚠️ **plan.md の MANUAL 節に差分が検出されました。**',
              '',
              '- `manual-accept` ラベルを付与すると MANUAL 差分を許容できます。',
              '- 意図しない差分であればローカルで差分を破棄して再実行してください。',
              '',
              '```diff',
              truncated,
              '```',
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.TARGET_PR),
              body,
            });

      - name: Fail when validation failed
        if: steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure'
        run: exit 1

      - name: Show doc_sync_plan
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -f doc_sync_plan.json ]; then
            cat doc_sync_plan.json
          fi

      - name: Detect plan changes
        if: steps.context.outputs.should_run == 'true'
        id: changes
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/agile/plan.md doc_sync_plan.json; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment no-op result
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.TARGET_PR),
              body: 'ℹ️ plan-sync を実行しましたが、自動更新が必要な差分はありませんでした (No-Op)。'
            });

      - name: Upload plan guard report
        if: steps.context.outputs.should_run == 'true' && hashFiles(env.PLAN_SYNC_RUN_REPORT) != ''
        uses: actions/upload-artifact@v4
        with:
          name: plan-limits-report
          path: ${{ env.PLAN_SYNC_RUN_REPORT }}

      - name: Enforce automation PR ceiling
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        id: pr-ceiling
        uses: actions/github-script@v7
        env:
          MAX_OPEN: ${{ env.PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS }}
          SOURCE_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const maxOpen = Number(process.env.MAX_OPEN || '0');
            if (!maxOpen) {
              core.info('PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS is 0; skipping PR ceiling check.');
              return;
            }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:docs-sync/plan`;
            const res = await github.rest.pulls.list({ owner, repo, head, state: 'open', per_page: 100 });
            const openCount = res.data.length;
            core.setOutput('open_count', String(openCount));
            if (openCount < maxOpen) {
              core.info(`Current automation PR count ${openCount} is within ceiling ${maxOpen}.`);
              return;
            }
            const message = `🛑 plan-sync stopped: automation PR ceiling reached (${openCount}/${maxOpen}).`;
            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No PR context available to report automation PR ceiling.');
            }
            core.setFailed(message);

      - name: Create / update plan PR
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true' && (steps.pr-ceiling.outcome == 'success' || steps.pr-ceiling.outcome == 'skipped')
        id: create-pr
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
        run: |
          set -euo pipefail
          git fetch origin docs-sync/plan || true
          git switch -C docs-sync/plan
          git add docs/agile/plan.md doc_sync_plan.json
          if git diff --cached --quiet; then
            echo "No plan changes to commit"
            exit 0
          fi
          git commit -m "chore(plan): sync plan AUTO sections"
          git push --force-with-lease origin HEAD:docs-sync/plan
          TRIGGER="${{ github.event_name }}"
          HEAD_REF="${{ steps.context.outputs.head_ref }}"
          PR_LINE="${{ steps.context.outputs.pr_number && format('- Source PR: #{0}', steps.context.outputs.pr_number) || '' }}"
          python3 -c 'import sys;from pathlib import Path;t,h,p=sys.argv[1:4];p=p.strip();lines=["Automated plan sync run.","",f"- Trigger: {t}",f"- Source ref: `{h}`"];lines.append(p) if p else None;Path("/tmp/plan-sync-body.txt").write_text("\n".join(lines)+"\n",encoding="utf-8")' "$TRIGGER" "$HEAD_REF" "$PR_LINE"
          if gh pr view docs-sync/plan >/dev/null 2>&1; then
            gh pr edit docs-sync/plan \
              --title "[plan-sync] docs: update plan auto sections" \
              --body-file /tmp/plan-sync-body.txt
          else
            gh pr create \
              --draft \
              --title "[plan-sync] docs: update plan auto sections" \
              --body-file /tmp/plan-sync-body.txt \
              --base ${{ steps.context.outputs.base_ref || 'main' }} \
              --head docs-sync/plan
          fi

      - name: Comment PR link
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = `${owner}:docs-sync/plan`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (!prs.data.length) {
              console.log('No plan-sync PR to comment');
              return;
            }
            const url = prs.data[0].html_url;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: `📋 plan-sync: ${url}`,
            });
