name: plan-sync/Validate

on:
  workflow_dispatch:
    inputs:
      pr:
        description: 'Pull request number to sync (optional)'
        required: false
      branch:
        description: 'Branch to run on when PR is not specified (default: main)'
        required: false
  pull_request_target:
    types: [labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

defaults:
  run:
    shell: bash

jobs:
  sync:
    name: plan-sync/Validate
    env:
      PLAN_SYNC_ALLOWED_PATHS: ${{ vars.PLAN_SYNC_ALLOWED_PATHS || 'docs/agile/**,docs/specs/**,docs/tests/**,.github/workflows/**,backend/app/openapi.yaml' }}
      PLAN_SYNC_BLOCKED_PATHS: ${{ vars.PLAN_SYNC_BLOCKED_PATHS || 'docs/secrets/**' }}
      PLAN_SYNC_MAX_CHANGED_LINES: ${{ vars.PLAN_SYNC_MAX_CHANGED_LINES || '300' }}
      PLAN_SYNC_MAX_CHANGED_FILES: ${{ vars.PLAN_SYNC_MAX_CHANGED_FILES || '4' }}
      PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS: ${{ vars.PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS || '2' }}
      PLAN_SYNC_RUN_REPORT: tmp/plan_limits_report.json
    concurrency:
      group: docs-sync-plan-${{ github.event.pull_request.number || github.ref_name || 'manual' }}
      cancel-in-progress: false
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request_target' && github.event.action == 'labeled') ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request)
    runs-on: ubuntu-latest
    steps:
      - name: Resolve run context
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const event = context.eventName;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const set = (key, value) => core.setOutput(key, value ?? '');

            if (event === 'workflow_dispatch') {
              const prInput = core.getInput('pr');
              const branchInput = core.getInput('branch');
              if (prInput) {
                const prNumber = Number(prInput);
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                set('should_run', 'true');
                set('pr_number', String(prNumber));
                set('checkout_ref', `refs/pull/${prNumber}/head`);
                set('base_ref', pr.data.base.ref);
                set('base_sha', pr.data.base.sha ?? '');
                set('head_ref', pr.data.head.ref);
                return;
              }
              const inferredBranch = branchInput || context.ref.replace('refs/heads/', '');
              set('should_run', 'true');
              set('pr_number', '');
              set('checkout_ref', `refs/heads/${inferredBranch}`);
              set('base_ref', 'main');
              set('base_sha', '');
              set('head_ref', inferredBranch);
              return;
            }

            if (event === 'pull_request_target') {
              const pr = context.payload.pull_request;
              const label = context.payload.label?.name;
              if (context.payload.action !== 'labeled' || label !== 'plan:sync') {
                set('should_run', 'false');
                set('reason', 'label condition not met');
                return;
              }
              if (pr.head.ref === 'docs-sync/plan') {
                set('should_run', 'false');
                set('reason', 'plan branch self-trigger');
                return;
              }
              set('should_run', 'true');
              set('pr_number', String(pr.number));
              set('checkout_ref', `refs/pull/${pr.number}/head`);
              set('base_ref', pr.base.ref);
              set('base_sha', pr.base.sha ?? '');
              set('head_ref', pr.head.ref);
              return;
            }

            if (event === 'issue_comment') {
              const prLink = context.payload.issue.pull_request;
              const body = (context.payload.comment.body || '').trim();
              if (!prLink) {
                set('should_run', 'false');
                set('reason', 'not a PR comment');
                return;
              }
              if (!/^\/plan\s+sync\b/i.test(body)) {
                set('should_run', 'false');
                set('reason', 'no slash command');
                return;
              }
              const actor = context.payload.comment.user?.login;
              if (!actor) {
                set('should_run', 'false');
                set('reason', 'missing commenter');
                return;
              }
              try {
                const permRes = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: actor });
                const permission = permRes.data.permission;
                const allowed = new Set(['admin', 'write', 'maintain']);
                if (!allowed.has(permission)) {
                  set('should_run', 'false');
                  set('reason', `insufficient permissions (${permission})`);
                  return;
                }
              } catch (error) {
                set('should_run', 'false');
                set('reason', 'failed to verify commenter permissions');
                return;
              }

              const prNumber = context.payload.issue.number;
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              if (pr.data.head.ref === 'docs-sync/plan') {
                set('should_run', 'false');
                set('reason', 'plan branch self-trigger');
                return;
              }
              set('should_run', 'true');
              set('pr_number', String(prNumber));
              set('checkout_ref', `refs/pull/${prNumber}/head`);
              set('base_ref', pr.data.base.ref);
              set('base_sha', pr.data.base.sha ?? '');
              set('head_ref', pr.data.head.ref);
              return;
            }

            set('should_run', 'false');
            set('reason', `unsupported event: ${event}`);

      - name: Skip (no action required)
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "plan-sync skipped: ${{ steps.context.outputs.reason || 'condition not met' }}"

      - name: Create GitHub App token
        if: steps.context.outputs.should_run == 'true'
        id: app-token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          owner: ${{ github.repository_owner }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Checkout target revision
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Configure git user
        if: steps.context.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Fetch base ref
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.base_ref != ''
        run: |
          git fetch --no-tags --prune --depth=1 origin "${{ steps.context.outputs.base_ref }}" || true
          if [ -n "${{ steps.context.outputs.base_sha }}" ]; then
            git fetch --no-tags --prune --depth=1 origin "${{ steps.context.outputs.base_sha }}" || true
          fi

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install minimal dependencies
        if: steps.context.outputs.should_run == 'true'
        run: |
          python3 -m pip install --upgrade pip
          pip install PyYAML==6.0.2

      - name: Run plan preflight & apply
        if: steps.context.outputs.should_run == 'true'
        id: plan-run
        continue-on-error: true
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          set -euo pipefail
          python -m scripts.plan_cli preflight
          python -m scripts.plan_cli apply

      - name: Handle guard outcome
        if: steps.context.outputs.should_run == 'true' && steps.plan-run.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ env.PLAN_SYNC_RUN_REPORT }}
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const core = require('@actions/core');
            let payload;
            try {
              payload = JSON.parse(fs.readFileSync(process.env.REPORT_PATH, 'utf-8'));
            } catch (error) {
              core.setFailed(`plan-sync failed but report ${process.env.REPORT_PATH} was not found: ${error}`);
              return;
            }
            const preflight = payload.preflight || {};
            const apply = payload.apply || {};

            let message;
            if (preflight.status === 'blocked_paths') {
              const files = (preflight.blocked_files || []).join(', ');
              message = `🛑 plan-sync stopped: blocked path detected (${files || 'unknown'})`;
            } else if (apply.status === 'limit_exceeded') {
              const type = apply.limit_type === 'lines' ? 'line change limit' : 'file limit';
              const limit = apply.limit_type === 'lines' ? apply.max_lines : apply.max_files;
              const actual = apply.actual ?? 'unknown';
              message = `🛑 plan-sync stopped: ${type} hit (${actual}/${limit}).`;
            }

            if (!message) {
              core.setFailed('plan-sync failed before producing a limit report. Check workflow logs.');
              return;
            }

            if (process.env.TARGET_PR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.TARGET_PR),
                body: message,
              });
            } else {
              core.warning('No PR context available to post guard message.');
            }

            core.setFailed(message);

      - name: Validate plan diff
        if: steps.context.outputs.should_run == 'true'
        id: validate
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p tmp
          args=()
          if [ -n "${{ steps.context.outputs.base_sha }}" ]; then
            args+=("--base-sha" "${{ steps.context.outputs.base_sha }}")
          fi
          python3 scripts/validate-agile-docs "${args[@]}" --manual-diff-report tmp/manual_diff.txt

      - name: Upload manual diff detail
        if: always() && steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure' && hashFiles('tmp/manual_diff.txt') != ''
        uses: actions/upload-artifact@v4
        with:
          name: plan-manual-diff
          path: tmp/manual_diff.txt

      - name: Comment manual diff guidance
        if: always() && steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure' && hashFiles('tmp/manual_diff.txt') != '' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const diff = fs.readFileSync('tmp/manual_diff.txt', 'utf-8');
            const truncated = diff.length > 6000 ? diff.slice(0, 6000) + '\n...[truncated]...' : diff;
            const body = [
              '⚠️ **plan.md の MANUAL 節に差分が検出されました。**',
              '',
              '- `manual-accept` ラベルを付与すると MANUAL 差分を許容できます。',
              '- 意図しない差分であればローカルで差分を破棄して再実行してください。',
              '',
              '```diff',
              truncated,
              '```',
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.TARGET_PR),
              body,
            });

      - name: Fail when validation failed
        if: steps.context.outputs.should_run == 'true' && steps.validate.outcome == 'failure'
        run: exit 1

      - name: Show doc_sync_plan
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -f doc_sync_plan.json ]; then
            cat doc_sync_plan.json
          fi

      - name: Detect plan changes
        if: steps.context.outputs.should_run == 'true'
        id: changes
        run: |
          set -euo pipefail
          if git diff --quiet -- docs/agile/plan.md doc_sync_plan.json; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment no-op result
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed != 'true' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          TARGET_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.TARGET_PR),
              body: 'ℹ️ plan-sync を実行しましたが、自動更新が必要な差分はありませんでした (No-Op)。'
            });

      - name: Enforce automation PR ceiling
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true'
        id: pr-ceiling
        uses: actions/github-script@v7
        env:
          MAX_OPEN: ${{ env.PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS }}
          SOURCE_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const core = require('@actions/core');
            const maxOpen = Number(process.env.MAX_OPEN || '0');
            if (!maxOpen) {
              core.info('PLAN_SYNC_MAX_OPEN_AUTOMATION_PRS is 0; skipping PR ceiling check.');
              return;
            }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:docs-sync/plan`;
            const res = await github.rest.pulls.list({ owner, repo, head, state: 'open', per_page: 100 });
            const openCount = res.data.length;
            core.setOutput('open_count', String(openCount));
            if (openCount < maxOpen) {
              core.info(`Current automation PR count ${openCount} is within ceiling ${maxOpen}.`);
              return;
            }
            const message = `🛑 plan-sync stopped: automation PR ceiling reached (${openCount}/${maxOpen}).`;
            if (process.env.SOURCE_PR) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: Number(process.env.SOURCE_PR),
                body: message,
              });
            } else {
              core.warning('No PR context available to report automation PR ceiling.');
            }
            core.setFailed(message);

      - name: Create / update plan PR
        if: steps.context.outputs.should_run == 'true' && steps.changes.outputs.changed == 'true' && (steps.pr-ceiling.outcome == 'success' || steps.pr-ceiling.outcome == 'skipped')
        id: create-pr
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
        run: |
          set -euo pipefail
          git fetch origin docs-sync/plan || true
          git switch -C docs-sync/plan
          git add docs/agile/plan.md doc_sync_plan.json
          if git diff --cached --quiet; then
            echo "No plan changes to commit"
            exit 0
          fi
          git commit -m "chore(plan): sync plan AUTO sections"
          git push --force-with-lease origin HEAD:docs-sync/plan
          TRIGGER="${{ github.event_name }}"
          HEAD_REF="${{ steps.context.outputs.head_ref }}"
          PR_LINE="${{ steps.context.outputs.pr_number && format('- Source PR: #{0}', steps.context.outputs.pr_number) || '' }}"
          python3 -c 'import sys;from pathlib import Path;t,h,p=sys.argv[1:4];p=p.strip();lines=["Automated plan sync run.","",f"- Trigger: {t}",f"- Source ref: `{h}`"];lines.append(p) if p else None;Path("/tmp/plan-sync-body.txt").write_text("\n".join(lines)+"\n",encoding="utf-8")' "$TRIGGER" "$HEAD_REF" "$PR_LINE"
          if gh pr view docs-sync/plan >/dev/null 2>&1; then
            gh pr edit docs-sync/plan \
              --title "[plan-sync] docs: update plan auto sections" \
              --body-file /tmp/plan-sync-body.txt
          else
            gh pr create \
              --draft \
              --title "[plan-sync] docs: update plan auto sections" \
              --body-file /tmp/plan-sync-body.txt \
              --base ${{ steps.context.outputs.base_ref || 'main' }} \
              --head docs-sync/plan
          fi

      - name: Comment PR link
        if: steps.context.outputs.should_run == 'true' && steps.context.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          SOURCE_PR: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headRef = `${owner}:docs-sync/plan`;
            const prs = await github.rest.pulls.list({ owner, repo, head: headRef, state: 'open', per_page: 1 });
            if (!prs.data.length) {
              console.log('No plan-sync PR to comment');
              return;
            }
            const url = prs.data[0].html_url;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: Number(process.env.SOURCE_PR),
              body: `📋 plan-sync: ${url}`,
            });
