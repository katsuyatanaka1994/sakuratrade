name: pr-label-guard
on:
  workflow_run:
    workflows: ["docs-index-validate", "nfr-xref", "security-permissions-lint"]
    types: [completed]
permissions:
  contents: read
  pull-requests: write
  issues: write
concurrency:
  group: pr-label-guard
  cancel-in-progress: true
jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ github.event.workflow_run.repository.full_name }}
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 1
      - uses: actions/github-script@v7
        with:
          script: |
            const path = require('path');
            const helperPath = path.join(process.env.GITHUB_WORKSPACE, '.github/scripts/ds27-check-state.js');
            const { evaluateChecks, REQUIRED_CHECKS } = require(helperPath);

            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;

            const resolvePullRequest = async () => {
              const direct = run.pull_requests?.[0];
              if (direct) {
                core.info(`DS-27: pull_request found in payload (#${direct.number})`);
                return direct;
              }

              const headSha = run.head_sha;
              if (!headSha) {
                core.warning('DS-27: workflow_run missing head_sha; cannot resolve PR');
                return null;
              }

              try {
                const associated = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: headSha });
                if (associated.data.length > 0) {
                  const pr = associated.data[0];
                  core.info(`DS-27: resolved PR #${pr.number} via associated commit`);
                  return pr;
                }
              } catch (error) {
                core.warning(`DS-27: failed listPullRequestsAssociatedWithCommit (${error?.message || error})`);
              }

              try {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: `${headSha} type:pr repo:${owner}/${repo}`,
                  per_page: 1,
                });
                const prItem = searchResult.data.items?.[0];
                if (prItem) {
                  core.info(`DS-27: resolved PR #${prItem.number} via search`);
                  const pr = await github.rest.pulls.get({ owner, repo, pull_number: prItem.number });
                  return pr.data;
                }
              } catch (error) {
                core.warning(`DS-27: fallback search failed (${error?.message || error})`);
              }

              core.warning('DS-27: unable to resolve PR from workflow_run');
              return null;
            };

            const pr = await resolvePullRequest();
            if (!pr) {
              core.info('DS-27: workflow run not tied to a PR; skipping label update');
              return;
            }

            let sha = run.head_sha || pr.head?.sha;
            if (!sha) {
              core.info('DS-27: resolving head SHA via API');
              try {
                const prData = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                sha = prData.data.head.sha;
              } catch (error) {
                core.warning(`DS-27: failed to resolve head SHA (${error?.message || error})`);
              }
            }

            const issue_number = pr.number;

            const ensureLabelPresent = async () => {
              core.info('DS-27: ensuring docs:invalid label is present');
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels: ['docs:invalid'] });
                core.info('DS-27: applied docs:invalid label');
              } catch (error) {
                if (error.status === 422) {
                  core.info('DS-27: docs:invalid label already present');
                } else {
                  throw error;
                }
              }
            };

            if (!sha) {
              core.warning('DS-27: missing head SHA; defaulting to keeping docs:invalid label');
              await ensureLabelPresent();
              return;
            }

            try {
              const evaluation = await evaluateChecks({ github, owner, repo, sha, requiredChecks: REQUIRED_CHECKS });

              if (evaluation.allSuccess) {
                core.info('DS-27: all required checks green; removing docs labels');
                for (const name of ['docs:invalid','triage:urgent']) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
                    core.info(`DS-27: removed ${name} label`);
                  } catch (error) {
                    if (error.status === 404) {
                      core.info(`DS-27: ${name} label already absent`);
                    } else {
                      throw error;
                    }
                  }
                }
              } else {
                await ensureLabelPresent();
              }
            } catch (error) {
              core.warning(`DS-27: evaluation failed (${error?.message || error}); defaulting to docs:invalid`);
              await ensureLabelPresent();
            }
