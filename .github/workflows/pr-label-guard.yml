name: pr-label-guard
on:
  workflow_run:
    workflows: ["docs-index-validate", "nfr-xref"]
    types: [completed]

env:
  DS16_MODE: ${{ vars.DS16_MODE || 'enforce' }}
permissions:
  contents: read
  pull-requests: write
  issues: write
concurrency:
  group: pr-label-guard
  cancel-in-progress: true
jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ github.event.workflow_run.repository.full_name }}
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 1
      - name: Checkout main for guard library
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.workflow_run.repository.full_name }}
          ref: main
          path: guardlib
          fetch-depth: 1
      - uses: actions/github-script@v7
        id: label
        with:
          script: |
            const path = require('path');
            const guardLibScript = path.join(process.env.GITHUB_WORKSPACE, 'guardlib', '.github', 'scripts', 'ds27-check-state.js');
            const { evaluateChecks } = require(guardLibScript);

            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;
            const headSha = run.head_sha;
            const runConclusion = (run?.conclusion || '').toLowerCase();
            const workflowRunFailed = runConclusion && runConclusion !== 'success';
            const mode = (process.env.DS16_MODE || 'observe').toLowerCase();
            const observeMode = mode === 'observe';

            const logMeta = ({ sha, prNumber, bothGreen, changedDocs }) => {
              const shaLabel = sha || 'none';
              const prLabel = prNumber || 'N/A';
              const docsLabel = typeof changedDocs === 'boolean' ? changedDocs : 'N/A';
              core.info(`DS-27: guard-meta head_sha=${shaLabel} resolved_pr=${prLabel} bothGreen=${bothGreen} changedDocs=${docsLabel}`);
            };

            const resolvePullRequestNumber = async () => {
              const payloadPR = run.pull_requests?.[0]?.number;
              if (payloadPR) {
                core.info(`DS-27: pull_request found in payload (#${payloadPR})`);
                return payloadPR;
              }

              if (!headSha) {
                core.warning('DS-27: workflow_run missing head_sha; cannot resolve PR');
                return null;
              }

              try {
                const associated = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: headSha });
                const match = associated.data.find(pr => pr.state === 'open' && pr.head?.sha === headSha);
                if (match) {
                  core.info(`DS-27: resolved PR #${match.number} via associated commit`);
                  return match.number;
                }
              } catch (error) {
                core.warning(`DS-27: failed listPullRequestsAssociatedWithCommit (${error?.message || error})`);
              }

              try {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:pr sha:${headSha}`,
                  per_page: 5,
                });
                const prItem = searchResult.data.items?.find(item => item.state === 'open');
                if (prItem) {
                  core.info(`DS-27: resolved PR #${prItem.number} via search`);
                  return prItem.number;
                }
              } catch (error) {
                core.warning(`DS-27: fallback search failed (${error?.message || error})`);
              }

              core.info('DS-27: unable to resolve PR from workflow_run payload/sha');
              return null;
            };

            const prNumber = await resolvePullRequestNumber();
            if (!prNumber) {
              logMeta({ sha: headSha, prNumber: null, bothGreen: false, changedDocs: 'N/A' });
              core.info('DS-27: workflow run not tied to a PR; skipping label update');
              return;
            }

            let sha = headSha;
            if (!sha) {
              try {
                const prData = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                sha = prData.data.head?.sha;
              } catch (error) {
                core.warning(`DS-27: failed to resolve head SHA (${error?.message || error})`);
              }
            }

            let changedDocs = null;
            try {
              const files = await github.paginate(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number: prNumber, per_page: 300 },
              );
              changedDocs = files.some((file) => (file.filename || '').startsWith('docs/'));
            } catch (error) {
              core.warning(`DS-27: failed to list files for PR #${prNumber} (${error?.message || error}); treating docs change as unknown`);
            }

            const removeDocsLabels = async () => {
              for (const name of ['docs:invalid','triage:urgent']) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                  core.info(`DS-27: removed ${name} label`);
                } catch (error) {
                  if (error.status !== 404) {
                    throw error;
                  }
                  core.info(`DS-27: ${name} already absent`);
                }
              }
            };

            const ensureLabelPresent = async () => {
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['docs:invalid'] });
                core.info('DS-27: applied docs:invalid label');
              } catch (error) {
                if (error.status === 422) {
                  core.info('DS-27: docs:invalid label already present');
                } else {
                  throw error;
                }
              }
            };

            if (changedDocs === false) {
              logMeta({ sha, prNumber, bothGreen: true, changedDocs });
              core.info('DS-27: no docs changes; ensure docs labels are absent and exit');
              await removeDocsLabels();
              return;
            }

            if (changedDocs === null) {
              logMeta({ sha, prNumber, bothGreen: false, changedDocs: 'unknown' });
              core.info('DS-27: docs change state unknown; leaving labels untouched');
              return;
            }

            if (!sha) {
              core.warning('DS-27: missing head SHA; defaulting to keeping docs:invalid label');
              logMeta({ sha, prNumber, bothGreen: false, changedDocs });
              await ensureLabelPresent();
              return;
            }

            try {
              const evaluation = await evaluateChecks({
                github,
                owner,
                repo,
                sha,
                requiredChecks: ['docs-index-validate','nfr-xref'],
              });
              const bothGreen = Boolean(evaluation?.allSuccess);
              const hasFailures = Array.isArray(evaluation?.notSuccess) && evaluation.notSuccess.length > 0;
              const hasPending = Array.isArray(evaluation?.pending) && evaluation.pending.length > 0;
              const hasMissing = Array.isArray(evaluation?.missing) && evaluation.missing.length > 0;

              logMeta({ sha, prNumber, bothGreen, changedDocs });
              core.info(`DS-27: evaluation details failures=${evaluation?.notSuccess?.length || 0} pending=${evaluation?.pending?.length || 0} missing=${evaluation?.missing?.length || 0}`);

              if (observeMode) {
                core.info(`DS-27: observe mode (${mode}); retaining docs:invalid label regardless of check status`);
                await ensureLabelPresent();
                return;
              }

              if (hasFailures || workflowRunFailed) {
                core.info('DS-27: failure detected via checks or workflow_run; ensuring docs:invalid label');
                await ensureLabelPresent();
                return;
              }

              if (bothGreen) {
                core.info('DS-27: all required checks passed; removing docs labels');
                await removeDocsLabels();
                return;
              }

              if (hasPending || hasMissing) {
                core.info('DS-27: required checks pending/missing; keeping docs labels cleared until verdict');
                await removeDocsLabels();
                return;
              }

              core.info('DS-27: evaluation inconclusive; defaulting to docs:invalid');
              await ensureLabelPresent();
            } catch (error) {
              core.warning(`DS-27: evaluation failed (${error?.message || error}); defaulting to docs:invalid`);
              logMeta({ sha, prNumber, bothGreen: false, changedDocs });
              await ensureLabelPresent();
            }
