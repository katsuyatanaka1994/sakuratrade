import { describe, it, expect } from 'vitest';\nimport {\n  calculatePositionMetrics,\n  calculateUpdateDiff,\n  formatPrice,\n  formatQty,\n  formatPercent,\n  formatPnl,\n  validatePosition,\n  validatePositionUpdate,\n  type PositionMetrics,\n  type PositionUpdateDiff\n} from '../utils/positionCalculations';\nimport type { Position, Side } from '../store/positions';\n\n// Test Position factory\nconst createTestPosition = (overrides: Partial<Position> = {}): Position => ({\n  symbol: '9984',\n  side: 'LONG',\n  qtyTotal: 100,\n  avgPrice: 15000,\n  lots: [{ price: 15000, qtyRemaining: 100, time: '2025-09-01T10:00:00Z' }],\n  realizedPnl: 0,\n  updatedAt: '2025-09-01T10:00:00Z',\n  name: 'ソフトバンクグループ',\n  chatId: 'test-chat',\n  currentTradeId: 'test-trade-123',\n  status: 'OPEN',\n  ownerId: 'user-123',\n  version: 1,\n  ...overrides\n});\n\ndescribe('positionCalculations', () => {\n  describe('calculatePositionMetrics', () => {\n    it('should calculate metrics for LONG position correctly', () => {\n      const position = createTestPosition();\n      const metrics = calculatePositionMetrics(position);\n\n      expect(metrics.totalValue).toBe(1500000); // 15000 * 100\n      expect(metrics.breakEvenPrice).toBe(15000);\n      expect(metrics.stopLossTarget).toBe(14250); // 15000 * 0.95\n      expect(metrics.profitTarget).toBe(16500); // 15000 * 1.10\n      expect(metrics.riskRatio).toBe(1); // (15000-14250) / (16500-15000) = 750/1500 = 0.5\n      expect(metrics.unrealizedPnl).toBe(0); // No current price provided\n      expect(metrics.unrealizedPnlPercent).toBe(0);\n    });\n\n    it('should calculate metrics for SHORT position correctly', () => {\n      const position = createTestPosition({ side: 'SHORT' });\n      const metrics = calculatePositionMetrics(position);\n\n      expect(metrics.totalValue).toBe(1500000);\n      expect(metrics.breakEvenPrice).toBe(15000);\n      expect(metrics.stopLossTarget).toBe(15750); // 15000 * 1.05 (SHORT)\n      expect(metrics.profitTarget).toBe(13500); // 15000 * 0.90 (SHORT)\n      expect(metrics.riskRatio).toBe(1); // Same ratio calculation\n    });\n\n    it('should calculate unrealized PnL for LONG position with current price', () => {\n      const position = createTestPosition();\n      const currentPrice = 16000;\n      const metrics = calculatePositionMetrics(position, currentPrice);\n\n      expect(metrics.unrealizedPnl).toBe(100000); // (16000 - 15000) * 100\n      expect(metrics.unrealizedPnlPercent).toBe(6.67); // 100000 / 1500000 * 100\n    });\n\n    it('should calculate unrealized PnL for SHORT position with current price', () => {\n      const position = createTestPosition({ side: 'SHORT' });\n      const currentPrice = 14000;\n      const metrics = calculatePositionMetrics(position, currentPrice);\n\n      expect(metrics.unrealizedPnl).toBe(100000); // (15000 - 14000) * 100\n      expect(metrics.unrealizedPnlPercent).toBe(6.67);\n    });\n\n    it('should handle custom risk settings', () => {\n      const position = createTestPosition();\n      const metrics = calculatePositionMetrics(position, undefined, {\n        stopLossPercent: 0.03, // 3%\n        profitTargetPercent: 0.15 // 15%\n      });\n\n      expect(metrics.stopLossTarget).toBe(14550); // 15000 * 0.97\n      expect(metrics.profitTarget).toBe(17250); // 15000 * 1.15\n    });\n\n    it('should handle edge case with zero quantity', () => {\n      const position = createTestPosition({ qtyTotal: 0 });\n      const metrics = calculatePositionMetrics(position);\n\n      expect(metrics.totalValue).toBe(0);\n      expect(metrics.unrealizedPnl).toBe(0);\n    });\n\n    it('should handle edge case with very low price', () => {\n      const position = createTestPosition({ avgPrice: 1 });\n      const metrics = calculatePositionMetrics(position);\n\n      expect(metrics.stopLossTarget).toBe(0.95); // 1 * 0.95\n      expect(metrics.profitTarget).toBe(1.10); // 1 * 1.10\n      expect(metrics.totalValue).toBe(100); // 1 * 100\n    });\n  });\n\n  describe('calculateUpdateDiff', () => {\n    it('should detect price changes', () => {\n      const oldPosition = createTestPosition({ avgPrice: 15000 });\n      const newPosition = createTestPosition({ avgPrice: 16000 });\n      const diff = calculateUpdateDiff(oldPosition, newPosition);\n\n      expect(diff.priceChanged).toBe(true);\n      expect(diff.qtyChanged).toBe(false);\n      expect(diff.sideChanged).toBe(false);\n      expect(diff.oldPrice).toBe(15000);\n      expect(diff.newPrice).toBe(16000);\n    });\n\n    it('should detect quantity changes', () => {\n      const oldPosition = createTestPosition({ qtyTotal: 100 });\n      const newPosition = createTestPosition({ qtyTotal: 200 });\n      const diff = calculateUpdateDiff(oldPosition, newPosition);\n\n      expect(diff.priceChanged).toBe(false);\n      expect(diff.qtyChanged).toBe(true);\n      expect(diff.sideChanged).toBe(false);\n      expect(diff.oldQty).toBe(100);\n      expect(diff.newQty).toBe(200);\n    });\n\n    it('should detect side changes', () => {\n      const oldPosition = createTestPosition({ side: 'LONG' });\n      const newPosition = createTestPosition({ side: 'SHORT' });\n      const diff = calculateUpdateDiff(oldPosition, newPosition);\n\n      expect(diff.priceChanged).toBe(false);\n      expect(diff.qtyChanged).toBe(false);\n      expect(diff.sideChanged).toBe(true);\n      expect(diff.oldSide).toBe('LONG');\n      expect(diff.newSide).toBe('SHORT');\n    });\n\n    it('should detect multiple changes', () => {\n      const oldPosition = createTestPosition({ \n        avgPrice: 15000, \n        qtyTotal: 100, \n        side: 'LONG' as Side \n      });\n      const newPosition = createTestPosition({ \n        avgPrice: 16000, \n        qtyTotal: 150, \n        side: 'SHORT' as Side \n      });\n      const diff = calculateUpdateDiff(oldPosition, newPosition);\n\n      expect(diff.priceChanged).toBe(true);\n      expect(diff.qtyChanged).toBe(true);\n      expect(diff.sideChanged).toBe(true);\n    });\n  });\n\n  describe('formatPrice', () => {\n    it('should format prices correctly', () => {\n      expect(formatPrice(15000)).toBe('¥15,000');\n      expect(formatPrice(1234567)).toBe('¥1,234,567');\n      expect(formatPrice(0.99)).toBe('¥1'); // Rounds to nearest integer\n      expect(formatPrice(1500.75)).toBe('¥1,501');\n    });\n  });\n\n  describe('formatQty', () => {\n    it('should format quantities correctly', () => {\n      expect(formatQty(100)).toBe('100株');\n      expect(formatQty(1000)).toBe('1,000株');\n      expect(formatQty(1)).toBe('1株');\n    });\n  });\n\n  describe('formatPercent', () => {\n    it('should format percentages correctly', () => {\n      expect(formatPercent(5.67)).toBe('+5.67%');\n      expect(formatPercent(-3.21)).toBe('-3.21%');\n      expect(formatPercent(0)).toBe('+0.00%');\n      expect(formatPercent(10.123, 1)).toBe('+10.1%');\n    });\n  });\n\n  describe('formatPnl', () => {\n    it('should format positive PnL correctly', () => {\n      const result = formatPnl(50000);\n      expect(result.text).toBe('+¥50,000');\n      expect(result.colorClass).toBe('text-green-600');\n      expect(result.sign).toBe('+');\n    });\n\n    it('should format negative PnL correctly', () => {\n      const result = formatPnl(-30000);\n      expect(result.text).toBe('-¥30,000');\n      expect(result.colorClass).toBe('text-red-600');\n      expect(result.sign).toBe('');\n    });\n\n    it('should format zero PnL correctly', () => {\n      const result = formatPnl(0);\n      expect(result.text).toBe('+¥0');\n      expect(result.colorClass).toBe('text-green-600');\n      expect(result.sign).toBe('+');\n    });\n  });\n\n  describe('validatePosition', () => {\n    it('should validate correct position', () => {\n      const position = createTestPosition();\n      const result = validatePosition(position);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should reject position with invalid price', () => {\n      const position = createTestPosition({ avgPrice: 0 });\n      const result = validatePosition(position);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('平均建値は0より大きい値である必要があります');\n    });\n\n    it('should reject position with invalid quantity', () => {\n      const position = createTestPosition({ qtyTotal: -10 });\n      const result = validatePosition(position);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('保有数量は0より大きい値である必要があります');\n    });\n\n    it('should reject position with invalid side', () => {\n      const position = createTestPosition({ side: 'INVALID' as Side });\n      const result = validatePosition(position);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('ポジションタイプはLONGまたはSHORTである必要があります');\n    });\n\n    it('should reject position with invalid version', () => {\n      const position = createTestPosition({ version: -1 });\n      const result = validatePosition(position);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('バージョン情報が不正です');\n    });\n  });\n\n  describe('validatePositionUpdate', () => {\n    it('should validate correct position update', () => {\n      const oldPosition = createTestPosition({ version: 1 });\n      const newPosition = createTestPosition({ version: 2, avgPrice: 16000 });\n      const result = validatePositionUpdate(oldPosition, newPosition);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should reject update with old version', () => {\n      const oldPosition = createTestPosition({ version: 2 });\n      const newPosition = createTestPosition({ version: 1 });\n      const result = validatePositionUpdate(oldPosition, newPosition);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('バージョンが古いため更新できません');\n    });\n\n    it('should warn about side changes', () => {\n      const oldPosition = createTestPosition({ version: 1, side: 'LONG' });\n      const newPosition = createTestPosition({ version: 2, side: 'SHORT' });\n      const result = validatePositionUpdate(oldPosition, newPosition);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.warnings).toContain('ポジションタイプが変更されました。リスク管理にご注意ください。');\n    });\n\n    it('should warn about large price changes', () => {\n      const oldPosition = createTestPosition({ version: 1, avgPrice: 10000 });\n      const newPosition = createTestPosition({ version: 2, avgPrice: 12000 });\n      const result = validatePositionUpdate(oldPosition, newPosition);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.warnings).toContain('建値が20.0%変更されました。');\n    });\n\n    it('should warn about large quantity changes', () => {\n      const oldPosition = createTestPosition({ version: 1, qtyTotal: 100 });\n      const newPosition = createTestPosition({ version: 2, qtyTotal: 200 });\n      const result = validatePositionUpdate(oldPosition, newPosition);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.warnings).toContain('保有数量が100.0%変更されました。');\n    });\n  });\n\n  describe('boundary value testing', () => {\n    it('should handle minimum values', () => {\n      const position = createTestPosition({ \n        avgPrice: 0.01, \n        qtyTotal: 1,\n        version: 0\n      });\n      const metrics = calculatePositionMetrics(position);\n      const validation = validatePosition(position);\n      \n      expect(metrics.totalValue).toBe(0.01);\n      expect(validation.isValid).toBe(true);\n    });\n\n    it('should handle large values', () => {\n      const position = createTestPosition({ \n        avgPrice: 1000000, \n        qtyTotal: 10000\n      });\n      const metrics = calculatePositionMetrics(position);\n      \n      expect(metrics.totalValue).toBe(10000000000); // 10 billion\n      expect(metrics.stopLossTarget).toBe(950000);\n      expect(metrics.profitTarget).toBe(1100000);\n    });\n\n    it('should handle side change with same values', () => {\n      const oldPosition = createTestPosition({ side: 'LONG' });\n      const newPosition = createTestPosition({ side: 'SHORT' });\n      const diff = calculateUpdateDiff(oldPosition, newPosition);\n      \n      expect(diff.sideChanged).toBe(true);\n      expect(diff.priceChanged).toBe(false);\n      expect(diff.qtyChanged).toBe(false);\n      \n      // Verify metrics change for different sides\n      const longMetrics = calculatePositionMetrics(oldPosition);\n      const shortMetrics = calculatePositionMetrics(newPosition);\n      \n      expect(longMetrics.stopLossTarget).toBeLessThan(longMetrics.breakEvenPrice);\n      expect(shortMetrics.stopLossTarget).toBeGreaterThan(shortMetrics.breakEvenPrice);\n    });\n  });\n});